/*
lcdn-deployment

LCDN Deployment API

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package lcdn_deployment

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type DefaultApi interface {

	/*
	DeployHyperCacheInstance HyperCache Instance.

	Create or update a HyperCache instance: This operation deploys a new HyperCache instance, or updates the details of an existing HyperCache instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param nodeId Uniquely identifies a HyperCache instance. 
	 @return ApiDeployHyperCacheInstanceRequest
	*/
	DeployHyperCacheInstance(ctx _context.Context, nodeId int32) ApiDeployHyperCacheInstanceRequest

	// DeployHyperCacheInstanceExecute executes the request
	//  @return HypercacheInstanceReadDetailed
	DeployHyperCacheInstanceExecute(r ApiDeployHyperCacheInstanceRequest) (HypercacheInstanceReadDetailed, *_nethttp.Response, error)

	/*
	DeployRequestRouterInstance RequestRouter Instance.

	Create or update a Request Router instance: This operation deploys a new Request Router instance, or updates the details of an existing Request Router instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param nodeId Uniquely identifies a RequestRouter instance. 
	 @return ApiDeployRequestRouterInstanceRequest
	*/
	DeployRequestRouterInstance(ctx _context.Context, nodeId int32) ApiDeployRequestRouterInstanceRequest

	// DeployRequestRouterInstanceExecute executes the request
	//  @return RequestrouterInstanceReadDetailed
	DeployRequestRouterInstanceExecute(r ApiDeployRequestRouterInstanceRequest) (RequestrouterInstanceReadDetailed, *_nethttp.Response, error)

	/*
	ListHyperCacheInstances HyperCache Instances

	List HyperCache instances: This operation returns a list of all HyperCache instances configured on the LCDN.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListHyperCacheInstancesRequest
	*/
	ListHyperCacheInstances(ctx _context.Context) ApiListHyperCacheInstancesRequest

	// ListHyperCacheInstancesExecute executes the request
	//  @return HypercacheInstanceCollection
	ListHyperCacheInstancesExecute(r ApiListHyperCacheInstancesRequest) (HypercacheInstanceCollection, *_nethttp.Response, error)

	/*
	ListRequestRouterInstances RequestRouter Instances

	List Request Router instances: This operation returns a list of all instances configured on Request Router.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListRequestRouterInstancesRequest
	*/
	ListRequestRouterInstances(ctx _context.Context) ApiListRequestRouterInstancesRequest

	// ListRequestRouterInstancesExecute executes the request
	//  @return RequestrouterInstanceCollection
	ListRequestRouterInstancesExecute(r ApiListRequestRouterInstancesRequest) (RequestrouterInstanceCollection, *_nethttp.Response, error)

	/*
	ReadHyperCacheInstance HyperCache Instance.

	Get a HyperCache instance: This operation retrieves the details of a HyperCache instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param nodeId Uniquely identifies a HyperCache instance. 
	 @return ApiReadHyperCacheInstanceRequest
	*/
	ReadHyperCacheInstance(ctx _context.Context, nodeId int32) ApiReadHyperCacheInstanceRequest

	// ReadHyperCacheInstanceExecute executes the request
	//  @return HypercacheInstanceReadDetailed
	ReadHyperCacheInstanceExecute(r ApiReadHyperCacheInstanceRequest) (HypercacheInstanceReadDetailed, *_nethttp.Response, error)

	/*
	ReadRequestRouterInstance RequestRouter Instance.

	Get a Request Router instance: This operation retrieves the details of a Request Router instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param nodeId Uniquely identifies a RequestRouter instance. 
	 @return ApiReadRequestRouterInstanceRequest
	*/
	ReadRequestRouterInstance(ctx _context.Context, nodeId int32) ApiReadRequestRouterInstanceRequest

	// ReadRequestRouterInstanceExecute executes the request
	//  @return RequestrouterInstanceReadDetailed
	ReadRequestRouterInstanceExecute(r ApiReadRequestRouterInstanceRequest) (RequestrouterInstanceReadDetailed, *_nethttp.Response, error)

	/*
	UndeployHyperCacheInstance HyperCache Instance.

	Remove a HyperCache instance: This operation deletes a HyperCache instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param nodeId Uniquely identifies a HyperCache instance. 
	 @return ApiUndeployHyperCacheInstanceRequest
	*/
	UndeployHyperCacheInstance(ctx _context.Context, nodeId int32) ApiUndeployHyperCacheInstanceRequest

	// UndeployHyperCacheInstanceExecute executes the request
	UndeployHyperCacheInstanceExecute(r ApiUndeployHyperCacheInstanceRequest) (*_nethttp.Response, error)

	/*
	UndeployRequestRouterInstance RequestRouter Instance.

	Remove a Request Router instance: This operation deletes a Request Router instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param nodeId Uniquely identifies a RequestRouter instance. 
	 @return ApiUndeployRequestRouterInstanceRequest
	*/
	UndeployRequestRouterInstance(ctx _context.Context, nodeId int32) ApiUndeployRequestRouterInstanceRequest

	// UndeployRequestRouterInstanceExecute executes the request
	UndeployRequestRouterInstanceExecute(r ApiUndeployRequestRouterInstanceRequest) (*_nethttp.Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiDeployHyperCacheInstanceRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	nodeId int32
	hypercacheInstanceUpdate *HypercacheInstanceUpdate
}

func (r ApiDeployHyperCacheInstanceRequest) HypercacheInstanceUpdate(hypercacheInstanceUpdate HypercacheInstanceUpdate) ApiDeployHyperCacheInstanceRequest {
	r.hypercacheInstanceUpdate = &hypercacheInstanceUpdate
	return r
}

func (r ApiDeployHyperCacheInstanceRequest) Execute() (HypercacheInstanceReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.DeployHyperCacheInstanceExecute(r)
}

/*
DeployHyperCacheInstance HyperCache Instance.

Create or update a HyperCache instance: This operation deploys a new HyperCache instance, or updates the details of an existing HyperCache instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Uniquely identifies a HyperCache instance. 
 @return ApiDeployHyperCacheInstanceRequest
*/
func (a *DefaultApiService) DeployHyperCacheInstance(ctx _context.Context, nodeId int32) ApiDeployHyperCacheInstanceRequest {
	return ApiDeployHyperCacheInstanceRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return HypercacheInstanceReadDetailed
func (a *DefaultApiService) DeployHyperCacheInstanceExecute(r ApiDeployHyperCacheInstanceRequest) (HypercacheInstanceReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  HypercacheInstanceReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeployHyperCacheInstance")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hypercache/instances/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", _neturl.PathEscape(parameterToString(r.nodeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.hypercacheInstanceUpdate == nil {
		return localVarReturnValue, nil, reportError("hypercacheInstanceUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hypercacheInstanceUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeployRequestRouterInstanceRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	nodeId int32
	requestrouterInstanceUpdate *RequestrouterInstanceUpdate
}

func (r ApiDeployRequestRouterInstanceRequest) RequestrouterInstanceUpdate(requestrouterInstanceUpdate RequestrouterInstanceUpdate) ApiDeployRequestRouterInstanceRequest {
	r.requestrouterInstanceUpdate = &requestrouterInstanceUpdate
	return r
}

func (r ApiDeployRequestRouterInstanceRequest) Execute() (RequestrouterInstanceReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.DeployRequestRouterInstanceExecute(r)
}

/*
DeployRequestRouterInstance RequestRouter Instance.

Create or update a Request Router instance: This operation deploys a new Request Router instance, or updates the details of an existing Request Router instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Uniquely identifies a RequestRouter instance. 
 @return ApiDeployRequestRouterInstanceRequest
*/
func (a *DefaultApiService) DeployRequestRouterInstance(ctx _context.Context, nodeId int32) ApiDeployRequestRouterInstanceRequest {
	return ApiDeployRequestRouterInstanceRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return RequestrouterInstanceReadDetailed
func (a *DefaultApiService) DeployRequestRouterInstanceExecute(r ApiDeployRequestRouterInstanceRequest) (RequestrouterInstanceReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RequestrouterInstanceReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeployRequestRouterInstance")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/request-router/instances/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", _neturl.PathEscape(parameterToString(r.nodeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestrouterInstanceUpdate == nil {
		return localVarReturnValue, nil, reportError("requestrouterInstanceUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestrouterInstanceUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListHyperCacheInstancesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// The view parameter may be used to request that either the summary or detailed view be returned.
func (r ApiListHyperCacheInstancesRequest) View(view string) ApiListHyperCacheInstancesRequest {
	r.view = &view
	return r
}
// The filter parameter may be used to filter the returned collection.
func (r ApiListHyperCacheInstancesRequest) Filter(filter string) ApiListHyperCacheInstancesRequest {
	r.filter = &filter
	return r
}
// The sortBy parameter may be used to specify the sort order of the returned collection.
func (r ApiListHyperCacheInstancesRequest) SortBy(sortBy string) ApiListHyperCacheInstancesRequest {
	r.sortBy = &sortBy
	return r
}
// The pageNumber parameter may be used to specify an offset into the results.  Useful to use in conjunction with pageSize.  Page number offset is 1-based.
func (r ApiListHyperCacheInstancesRequest) PageNumber(pageNumber int32) ApiListHyperCacheInstancesRequest {
	r.pageNumber = &pageNumber
	return r
}
// The pageSize parameter may be used to specify the page size of the returned results.  Useful to use in conjunction with pageNumber.
func (r ApiListHyperCacheInstancesRequest) PageSize(pageSize int32) ApiListHyperCacheInstancesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListHyperCacheInstancesRequest) Execute() (HypercacheInstanceCollection, *_nethttp.Response, error) {
	return r.ApiService.ListHyperCacheInstancesExecute(r)
}

/*
ListHyperCacheInstances HyperCache Instances

List HyperCache instances: This operation returns a list of all HyperCache instances configured on the LCDN.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListHyperCacheInstancesRequest
*/
func (a *DefaultApiService) ListHyperCacheInstances(ctx _context.Context) ApiListHyperCacheInstancesRequest {
	return ApiListHyperCacheInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return HypercacheInstanceCollection
func (a *DefaultApiService) ListHyperCacheInstancesExecute(r ApiListHyperCacheInstancesRequest) (HypercacheInstanceCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  HypercacheInstanceCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListHyperCacheInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hypercache/instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListRequestRouterInstancesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiListRequestRouterInstancesRequest) Execute() (RequestrouterInstanceCollection, *_nethttp.Response, error) {
	return r.ApiService.ListRequestRouterInstancesExecute(r)
}

/*
ListRequestRouterInstances RequestRouter Instances

List Request Router instances: This operation returns a list of all instances configured on Request Router.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListRequestRouterInstancesRequest
*/
func (a *DefaultApiService) ListRequestRouterInstances(ctx _context.Context) ApiListRequestRouterInstancesRequest {
	return ApiListRequestRouterInstancesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RequestrouterInstanceCollection
func (a *DefaultApiService) ListRequestRouterInstancesExecute(r ApiListRequestRouterInstancesRequest) (RequestrouterInstanceCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RequestrouterInstanceCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListRequestRouterInstances")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/request-router/instances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadHyperCacheInstanceRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	nodeId int32
}


func (r ApiReadHyperCacheInstanceRequest) Execute() (HypercacheInstanceReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.ReadHyperCacheInstanceExecute(r)
}

/*
ReadHyperCacheInstance HyperCache Instance.

Get a HyperCache instance: This operation retrieves the details of a HyperCache instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Uniquely identifies a HyperCache instance. 
 @return ApiReadHyperCacheInstanceRequest
*/
func (a *DefaultApiService) ReadHyperCacheInstance(ctx _context.Context, nodeId int32) ApiReadHyperCacheInstanceRequest {
	return ApiReadHyperCacheInstanceRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return HypercacheInstanceReadDetailed
func (a *DefaultApiService) ReadHyperCacheInstanceExecute(r ApiReadHyperCacheInstanceRequest) (HypercacheInstanceReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  HypercacheInstanceReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadHyperCacheInstance")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hypercache/instances/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", _neturl.PathEscape(parameterToString(r.nodeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadRequestRouterInstanceRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	nodeId int32
}


func (r ApiReadRequestRouterInstanceRequest) Execute() (RequestrouterInstanceReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.ReadRequestRouterInstanceExecute(r)
}

/*
ReadRequestRouterInstance RequestRouter Instance.

Get a Request Router instance: This operation retrieves the details of a Request Router instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Uniquely identifies a RequestRouter instance. 
 @return ApiReadRequestRouterInstanceRequest
*/
func (a *DefaultApiService) ReadRequestRouterInstance(ctx _context.Context, nodeId int32) ApiReadRequestRouterInstanceRequest {
	return ApiReadRequestRouterInstanceRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return RequestrouterInstanceReadDetailed
func (a *DefaultApiService) ReadRequestRouterInstanceExecute(r ApiReadRequestRouterInstanceRequest) (RequestrouterInstanceReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  RequestrouterInstanceReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadRequestRouterInstance")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/request-router/instances/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", _neturl.PathEscape(parameterToString(r.nodeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUndeployHyperCacheInstanceRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	nodeId int32
}


func (r ApiUndeployHyperCacheInstanceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UndeployHyperCacheInstanceExecute(r)
}

/*
UndeployHyperCacheInstance HyperCache Instance.

Remove a HyperCache instance: This operation deletes a HyperCache instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Uniquely identifies a HyperCache instance. 
 @return ApiUndeployHyperCacheInstanceRequest
*/
func (a *DefaultApiService) UndeployHyperCacheInstance(ctx _context.Context, nodeId int32) ApiUndeployHyperCacheInstanceRequest {
	return ApiUndeployHyperCacheInstanceRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultApiService) UndeployHyperCacheInstanceExecute(r ApiUndeployHyperCacheInstanceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UndeployHyperCacheInstance")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/hypercache/instances/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", _neturl.PathEscape(parameterToString(r.nodeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUndeployRequestRouterInstanceRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	nodeId int32
}


func (r ApiUndeployRequestRouterInstanceRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UndeployRequestRouterInstanceExecute(r)
}

/*
UndeployRequestRouterInstance RequestRouter Instance.

Remove a Request Router instance: This operation deletes a Request Router instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Uniquely identifies a RequestRouter instance. 
 @return ApiUndeployRequestRouterInstanceRequest
*/
func (a *DefaultApiService) UndeployRequestRouterInstance(ctx _context.Context, nodeId int32) ApiUndeployRequestRouterInstanceRequest {
	return ApiUndeployRequestRouterInstanceRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultApiService) UndeployRequestRouterInstanceExecute(r ApiUndeployRequestRouterInstanceRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UndeployRequestRouterInstance")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/request-router/instances/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", _neturl.PathEscape(parameterToString(r.nodeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
