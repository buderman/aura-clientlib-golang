/*
lcdn-mapping

Aura LCDN Mapping API

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package lcdn_mapping

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type DefaultApi interface {

	/*
	CreateAccessMap AccessMap collection

	Create a new access map: This operation creates a new Access Map instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiCreateAccessMapRequest
	*/
	CreateAccessMap(ctx _context.Context) ApiCreateAccessMapRequest

	// CreateAccessMapExecute executes the request
	//  @return AccessMapReadDetailed
	CreateAccessMapExecute(r ApiCreateAccessMapRequest) (AccessMapReadDetailed, *_nethttp.Response, error)

	/*
	CreateBgpConfig BgpConfig collection

	Create a new BGP configuration: This operation creates a new BGP configuration instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiCreateBgpConfigRequest
	*/
	CreateBgpConfig(ctx _context.Context) ApiCreateBgpConfigRequest

	// CreateBgpConfigExecute executes the request
	//  @return BgpConfigReadDetailed
	CreateBgpConfigExecute(r ApiCreateBgpConfigRequest) (BgpConfigReadDetailed, *_nethttp.Response, error)

	/*
	CreateGeoIpConfig GeoIpConfig collection

	Create a new GeoIP configuration: This operation creates a new GeoIP configuration instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiCreateGeoIpConfigRequest
	*/
	CreateGeoIpConfig(ctx _context.Context) ApiCreateGeoIpConfigRequest

	// CreateGeoIpConfigExecute executes the request
	//  @return GeoipConfigReadDetailed
	CreateGeoIpConfigExecute(r ApiCreateGeoIpConfigRequest) (GeoipConfigReadDetailed, *_nethttp.Response, error)

	/*
	CreateSiteMap SiteMap collection

	Create a new site map: This operation creates a new site map instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiCreateSiteMapRequest
	*/
	CreateSiteMap(ctx _context.Context) ApiCreateSiteMapRequest

	// CreateSiteMapExecute executes the request
	//  @return SiteMapReadDetailed
	CreateSiteMapExecute(r ApiCreateSiteMapRequest) (SiteMapReadDetailed, *_nethttp.Response, error)

	/*
	DeleteAccessMap AccessMap Instance.

	Remove an access map: This operation removes an access map.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param mapId Uniquely identifies an access map instance. 
	 @return ApiDeleteAccessMapRequest
	*/
	DeleteAccessMap(ctx _context.Context, mapId int32) ApiDeleteAccessMapRequest

	// DeleteAccessMapExecute executes the request
	DeleteAccessMapExecute(r ApiDeleteAccessMapRequest) (*_nethttp.Response, error)

	/*
	DeleteBgpConfig BgpConfig Instance.

	Remove a BGP configuration: This operation removes a BGP configuration instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param bgpConfigId Uniquely identifies a BGP configuration instance. 
	 @return ApiDeleteBgpConfigRequest
	*/
	DeleteBgpConfig(ctx _context.Context, bgpConfigId int32) ApiDeleteBgpConfigRequest

	// DeleteBgpConfigExecute executes the request
	DeleteBgpConfigExecute(r ApiDeleteBgpConfigRequest) (*_nethttp.Response, error)

	/*
	DeleteGeoIpConfig GeoIpConfig Instance.

	Remove a GeoIP configuration: This operation removes a GeoIP configuration instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param geoIpConfigId Uniquely identifies a GeoIP configuration instance. 
	 @return ApiDeleteGeoIpConfigRequest
	*/
	DeleteGeoIpConfig(ctx _context.Context, geoIpConfigId int32) ApiDeleteGeoIpConfigRequest

	// DeleteGeoIpConfigExecute executes the request
	DeleteGeoIpConfigExecute(r ApiDeleteGeoIpConfigRequest) (*_nethttp.Response, error)

	/*
	DeleteSiteMap SiteMap Instance.

	Remove a site map: This operation removes a site map instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param mapId Uniquely identifies a site map instance. 
	 @return ApiDeleteSiteMapRequest
	*/
	DeleteSiteMap(ctx _context.Context, mapId int32) ApiDeleteSiteMapRequest

	// DeleteSiteMapExecute executes the request
	DeleteSiteMapExecute(r ApiDeleteSiteMapRequest) (*_nethttp.Response, error)

	/*
	ListAccessMaps AccessMap collection

	List access maps: This operation returns a list of all configured access maps.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListAccessMapsRequest
	*/
	ListAccessMaps(ctx _context.Context) ApiListAccessMapsRequest

	// ListAccessMapsExecute executes the request
	//  @return AccessMapCollection
	ListAccessMapsExecute(r ApiListAccessMapsRequest) (AccessMapCollection, *_nethttp.Response, error)

	/*
	ListBgpConfigs BgpConfig collection

	List BGP configurations: This operation returns a list of all BGP configurations.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListBgpConfigsRequest
	*/
	ListBgpConfigs(ctx _context.Context) ApiListBgpConfigsRequest

	// ListBgpConfigsExecute executes the request
	//  @return BgpConfigCollection
	ListBgpConfigsExecute(r ApiListBgpConfigsRequest) (BgpConfigCollection, *_nethttp.Response, error)

	/*
	ListGeoIpConfigs GeoIpConfig collection

	List GeoIP configurations: This operation returns a list of all GeoIP configurations.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListGeoIpConfigsRequest
	*/
	ListGeoIpConfigs(ctx _context.Context) ApiListGeoIpConfigsRequest

	// ListGeoIpConfigsExecute executes the request
	//  @return GeoipConfigCollection
	ListGeoIpConfigsExecute(r ApiListGeoIpConfigsRequest) (GeoipConfigCollection, *_nethttp.Response, error)

	/*
	ListSiteMaps SiteMap collection

	List site maps: This operation returns a list of all configured site maps.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListSiteMapsRequest
	*/
	ListSiteMaps(ctx _context.Context) ApiListSiteMapsRequest

	// ListSiteMapsExecute executes the request
	//  @return SiteMapCollection
	ListSiteMapsExecute(r ApiListSiteMapsRequest) (SiteMapCollection, *_nethttp.Response, error)

	/*
	ReadAccessMap AccessMap Instance.

	Get an access map: This operation gets the details of an access map instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param mapId Uniquely identifies an access map instance. 
	 @return ApiReadAccessMapRequest
	*/
	ReadAccessMap(ctx _context.Context, mapId int32) ApiReadAccessMapRequest

	// ReadAccessMapExecute executes the request
	//  @return AccessMapReadDetailed
	ReadAccessMapExecute(r ApiReadAccessMapRequest) (AccessMapReadDetailed, *_nethttp.Response, error)

	/*
	ReadAccessMapContent AccessMap Instance Map Content.

	Get a access map content: This operation gets the details of a access map instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param mapId Uniquely identifies an access map instance. 
	 @return ApiReadAccessMapContentRequest
	*/
	ReadAccessMapContent(ctx _context.Context, mapId int32) ApiReadAccessMapContentRequest

	// ReadAccessMapContentExecute executes the request
	ReadAccessMapContentExecute(r ApiReadAccessMapContentRequest) (*_nethttp.Response, error)

	/*
	ReadBgpConfig BgpConfig Instance.

	Get a BGP configuration: This operation gets the details of a BGP configuration instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param bgpConfigId Uniquely identifies a BGP configuration instance. 
	 @return ApiReadBgpConfigRequest
	*/
	ReadBgpConfig(ctx _context.Context, bgpConfigId int32) ApiReadBgpConfigRequest

	// ReadBgpConfigExecute executes the request
	//  @return BgpConfigReadDetailed
	ReadBgpConfigExecute(r ApiReadBgpConfigRequest) (BgpConfigReadDetailed, *_nethttp.Response, error)

	/*
	ReadBgpConfigContent BgpConfig Instance BGP configuration.

	Get a BGP config content: This operation gets the details of a BGP configuration.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param bgpConfigId Uniquely identifies a BGP configuration instance. 
	 @return ApiReadBgpConfigContentRequest
	*/
	ReadBgpConfigContent(ctx _context.Context, bgpConfigId int32) ApiReadBgpConfigContentRequest

	// ReadBgpConfigContentExecute executes the request
	ReadBgpConfigContentExecute(r ApiReadBgpConfigContentRequest) (*_nethttp.Response, error)

	/*
	ReadGeoIpConfig GeoIpConfig Instance.

	Get a GeoIP configuration: This operation retrieves the details of a GeoIP configuration instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param geoIpConfigId Uniquely identifies a GeoIP configuration instance. 
	 @return ApiReadGeoIpConfigRequest
	*/
	ReadGeoIpConfig(ctx _context.Context, geoIpConfigId int32) ApiReadGeoIpConfigRequest

	// ReadGeoIpConfigExecute executes the request
	//  @return GeoipConfigReadDetailed
	ReadGeoIpConfigExecute(r ApiReadGeoIpConfigRequest) (GeoipConfigReadDetailed, *_nethttp.Response, error)

	/*
	ReadGeoIpConfigContent GeoIpConfig Instance GeoIP configuration.

	Get a GeoIP config content: This operation gets the details of a GeoIP configuration.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param geoIpConfigId Uniquely identifies a GeoIP configuration instance. 
	 @return ApiReadGeoIpConfigContentRequest
	*/
	ReadGeoIpConfigContent(ctx _context.Context, geoIpConfigId int32) ApiReadGeoIpConfigContentRequest

	// ReadGeoIpConfigContentExecute executes the request
	ReadGeoIpConfigContentExecute(r ApiReadGeoIpConfigContentRequest) (*_nethttp.Response, error)

	/*
	ReadSiteMap SiteMap Instance.

	Get a site map: This operation gets the details of a site map instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param mapId Uniquely identifies a site map instance. 
	 @return ApiReadSiteMapRequest
	*/
	ReadSiteMap(ctx _context.Context, mapId int32) ApiReadSiteMapRequest

	// ReadSiteMapExecute executes the request
	//  @return SiteMapReadDetailed
	ReadSiteMapExecute(r ApiReadSiteMapRequest) (SiteMapReadDetailed, *_nethttp.Response, error)

	/*
	ReadSiteMapContent SiteMap Instance Map Content.

	Get a site map content: This operation gets the content of a site map instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param mapId Uniquely identifies a site map instance. 
	 @return ApiReadSiteMapContentRequest
	*/
	ReadSiteMapContent(ctx _context.Context, mapId int32) ApiReadSiteMapContentRequest

	// ReadSiteMapContentExecute executes the request
	ReadSiteMapContentExecute(r ApiReadSiteMapContentRequest) (*_nethttp.Response, error)

	/*
	UpdateAccessMap AccessMap Instance.

	Update an access map: This operation updates the details of an access map instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param mapId Uniquely identifies an access map instance. 
	 @return ApiUpdateAccessMapRequest
	*/
	UpdateAccessMap(ctx _context.Context, mapId int32) ApiUpdateAccessMapRequest

	// UpdateAccessMapExecute executes the request
	//  @return AccessMapReadDetailed
	UpdateAccessMapExecute(r ApiUpdateAccessMapRequest) (AccessMapReadDetailed, *_nethttp.Response, error)

	/*
	UpdateAccessMapContent AccessMap Instance Map Content.

	Update a site map content: This operation updates the content of a site map instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param mapId Uniquely identifies an access map instance. 
	 @return ApiUpdateAccessMapContentRequest
	*/
	UpdateAccessMapContent(ctx _context.Context, mapId int32) ApiUpdateAccessMapContentRequest

	// UpdateAccessMapContentExecute executes the request
	UpdateAccessMapContentExecute(r ApiUpdateAccessMapContentRequest) (*_nethttp.Response, error)

	/*
	UpdateBgpConfig BgpConfig Instance.

	Update a BGP configuration: This operation updates the details of a BGP configuration instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param bgpConfigId Uniquely identifies a BGP configuration instance. 
	 @return ApiUpdateBgpConfigRequest
	*/
	UpdateBgpConfig(ctx _context.Context, bgpConfigId int32) ApiUpdateBgpConfigRequest

	// UpdateBgpConfigExecute executes the request
	//  @return BgpConfigReadDetailed
	UpdateBgpConfigExecute(r ApiUpdateBgpConfigRequest) (BgpConfigReadDetailed, *_nethttp.Response, error)

	/*
	UpdateBgpConfigContent BgpConfig Instance BGP configuration.

	Update a BgpConfig Instance BGP configuration: This operation updates the content of a
BGP configuration.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param bgpConfigId Uniquely identifies a BGP configuration instance. 
	 @return ApiUpdateBgpConfigContentRequest
	*/
	UpdateBgpConfigContent(ctx _context.Context, bgpConfigId int32) ApiUpdateBgpConfigContentRequest

	// UpdateBgpConfigContentExecute executes the request
	UpdateBgpConfigContentExecute(r ApiUpdateBgpConfigContentRequest) (*_nethttp.Response, error)

	/*
	UpdateGeoIpConfig GeoIpConfig Instance.

	Update a GeoIP configuration: This operation updates the details of a GeoIP configuration instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param geoIpConfigId Uniquely identifies a GeoIP configuration instance. 
	 @return ApiUpdateGeoIpConfigRequest
	*/
	UpdateGeoIpConfig(ctx _context.Context, geoIpConfigId int32) ApiUpdateGeoIpConfigRequest

	// UpdateGeoIpConfigExecute executes the request
	//  @return GeoipConfigReadDetailed
	UpdateGeoIpConfigExecute(r ApiUpdateGeoIpConfigRequest) (GeoipConfigReadDetailed, *_nethttp.Response, error)

	/*
	UpdateGeoIpConfigContent GeoIpConfig Instance GeoIP configuration.

	Update a GeoIpConfig Instance GeoIP configuration: This operation updates the content of a
GeoIP configuration.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param geoIpConfigId Uniquely identifies a GeoIP configuration instance. 
	 @return ApiUpdateGeoIpConfigContentRequest
	*/
	UpdateGeoIpConfigContent(ctx _context.Context, geoIpConfigId int32) ApiUpdateGeoIpConfigContentRequest

	// UpdateGeoIpConfigContentExecute executes the request
	UpdateGeoIpConfigContentExecute(r ApiUpdateGeoIpConfigContentRequest) (*_nethttp.Response, error)

	/*
	UpdateSiteMap SiteMap Instance.

	Update a site map: This operation updates the details of a site map instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param mapId Uniquely identifies a site map instance. 
	 @return ApiUpdateSiteMapRequest
	*/
	UpdateSiteMap(ctx _context.Context, mapId int32) ApiUpdateSiteMapRequest

	// UpdateSiteMapExecute executes the request
	//  @return SiteMapReadDetailed
	UpdateSiteMapExecute(r ApiUpdateSiteMapRequest) (SiteMapReadDetailed, *_nethttp.Response, error)

	/*
	UpdateSiteMapContent SiteMap Instance Map Content.

	Update a site map content: This operation updates the content of a site map instance.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param mapId Uniquely identifies a site map instance. 
	 @return ApiUpdateSiteMapContentRequest
	*/
	UpdateSiteMapContent(ctx _context.Context, mapId int32) ApiUpdateSiteMapContentRequest

	// UpdateSiteMapContentExecute executes the request
	UpdateSiteMapContentExecute(r ApiUpdateSiteMapContentRequest) (*_nethttp.Response, error)

	/*
	ValidateAccessMap /validate

	Validate an access map: This operation validates an Access Map, and may be used to ensure
correct syntax when preparing to apply a map.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiValidateAccessMapRequest
	*/
	ValidateAccessMap(ctx _context.Context) ApiValidateAccessMapRequest

	// ValidateAccessMapExecute executes the request
	ValidateAccessMapExecute(r ApiValidateAccessMapRequest) (*_nethttp.Response, error)

	/*
	ValidateSiteMap /validate

	Validates a site map: This operation validates a site map, and may be used to ensure correct syntax when preparing to apply a map.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiValidateSiteMapRequest
	*/
	ValidateSiteMap(ctx _context.Context) ApiValidateSiteMapRequest

	// ValidateSiteMapExecute executes the request
	ValidateSiteMapExecute(r ApiValidateSiteMapRequest) (*_nethttp.Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiCreateAccessMapRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	metadata *AccessMapCreate
	config *interface{}
}

func (r ApiCreateAccessMapRequest) Metadata(metadata AccessMapCreate) ApiCreateAccessMapRequest {
	r.metadata = &metadata
	return r
}
func (r ApiCreateAccessMapRequest) Config(config interface{}) ApiCreateAccessMapRequest {
	r.config = &config
	return r
}

func (r ApiCreateAccessMapRequest) Execute() (AccessMapReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.CreateAccessMapExecute(r)
}

/*
CreateAccessMap AccessMap collection

Create a new access map: This operation creates a new Access Map instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAccessMapRequest
*/
func (a *DefaultApiService) CreateAccessMap(ctx _context.Context) ApiCreateAccessMapRequest {
	return ApiCreateAccessMapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccessMapReadDetailed
func (a *DefaultApiService) CreateAccessMapExecute(r ApiCreateAccessMapRequest) (AccessMapReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccessMapReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateAccessMap")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access-maps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.metadata != nil {
		paramJson, err := parameterToJson(*r.metadata)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("metadata", paramJson)
	}
	if r.config != nil {
		localVarFormParams.Add("config", parameterToString(*r.config, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateBgpConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	metadata *BgpConfigCreate
	config *interface{}
}

func (r ApiCreateBgpConfigRequest) Metadata(metadata BgpConfigCreate) ApiCreateBgpConfigRequest {
	r.metadata = &metadata
	return r
}
func (r ApiCreateBgpConfigRequest) Config(config interface{}) ApiCreateBgpConfigRequest {
	r.config = &config
	return r
}

func (r ApiCreateBgpConfigRequest) Execute() (BgpConfigReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.CreateBgpConfigExecute(r)
}

/*
CreateBgpConfig BgpConfig collection

Create a new BGP configuration: This operation creates a new BGP configuration instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateBgpConfigRequest
*/
func (a *DefaultApiService) CreateBgpConfig(ctx _context.Context) ApiCreateBgpConfigRequest {
	return ApiCreateBgpConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BgpConfigReadDetailed
func (a *DefaultApiService) CreateBgpConfigExecute(r ApiCreateBgpConfigRequest) (BgpConfigReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BgpConfigReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateBgpConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bgp-configs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.metadata != nil {
		paramJson, err := parameterToJson(*r.metadata)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("metadata", paramJson)
	}
	if r.config != nil {
		localVarFormParams.Add("config", parameterToString(*r.config, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGeoIpConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	metadata *GeoipConfigCreate
	config *interface{}
}

func (r ApiCreateGeoIpConfigRequest) Metadata(metadata GeoipConfigCreate) ApiCreateGeoIpConfigRequest {
	r.metadata = &metadata
	return r
}
func (r ApiCreateGeoIpConfigRequest) Config(config interface{}) ApiCreateGeoIpConfigRequest {
	r.config = &config
	return r
}

func (r ApiCreateGeoIpConfigRequest) Execute() (GeoipConfigReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.CreateGeoIpConfigExecute(r)
}

/*
CreateGeoIpConfig GeoIpConfig collection

Create a new GeoIP configuration: This operation creates a new GeoIP configuration instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGeoIpConfigRequest
*/
func (a *DefaultApiService) CreateGeoIpConfig(ctx _context.Context) ApiCreateGeoIpConfigRequest {
	return ApiCreateGeoIpConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GeoipConfigReadDetailed
func (a *DefaultApiService) CreateGeoIpConfigExecute(r ApiCreateGeoIpConfigRequest) (GeoipConfigReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GeoipConfigReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateGeoIpConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/geoip-configs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.metadata != nil {
		paramJson, err := parameterToJson(*r.metadata)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("metadata", paramJson)
	}
	if r.config != nil {
		localVarFormParams.Add("config", parameterToString(*r.config, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSiteMapRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	metadata *SiteMapCreate
	config *interface{}
}

func (r ApiCreateSiteMapRequest) Metadata(metadata SiteMapCreate) ApiCreateSiteMapRequest {
	r.metadata = &metadata
	return r
}
func (r ApiCreateSiteMapRequest) Config(config interface{}) ApiCreateSiteMapRequest {
	r.config = &config
	return r
}

func (r ApiCreateSiteMapRequest) Execute() (SiteMapReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.CreateSiteMapExecute(r)
}

/*
CreateSiteMap SiteMap collection

Create a new site map: This operation creates a new site map instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSiteMapRequest
*/
func (a *DefaultApiService) CreateSiteMap(ctx _context.Context) ApiCreateSiteMapRequest {
	return ApiCreateSiteMapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SiteMapReadDetailed
func (a *DefaultApiService) CreateSiteMapExecute(r ApiCreateSiteMapRequest) (SiteMapReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SiteMapReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSiteMap")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/site-maps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.metadata != nil {
		paramJson, err := parameterToJson(*r.metadata)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("metadata", paramJson)
	}
	if r.config != nil {
		localVarFormParams.Add("config", parameterToString(*r.config, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAccessMapRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	mapId int32
}


func (r ApiDeleteAccessMapRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteAccessMapExecute(r)
}

/*
DeleteAccessMap AccessMap Instance.

Remove an access map: This operation removes an access map.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapId Uniquely identifies an access map instance. 
 @return ApiDeleteAccessMapRequest
*/
func (a *DefaultApiService) DeleteAccessMap(ctx _context.Context, mapId int32) ApiDeleteAccessMapRequest {
	return ApiDeleteAccessMapRequest{
		ApiService: a,
		ctx: ctx,
		mapId: mapId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteAccessMapExecute(r ApiDeleteAccessMapRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteAccessMap")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access-maps/{mapId}"
	localVarPath = strings.Replace(localVarPath, "{"+"mapId"+"}", _neturl.PathEscape(parameterToString(r.mapId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteBgpConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	bgpConfigId int32
}


func (r ApiDeleteBgpConfigRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteBgpConfigExecute(r)
}

/*
DeleteBgpConfig BgpConfig Instance.

Remove a BGP configuration: This operation removes a BGP configuration instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bgpConfigId Uniquely identifies a BGP configuration instance. 
 @return ApiDeleteBgpConfigRequest
*/
func (a *DefaultApiService) DeleteBgpConfig(ctx _context.Context, bgpConfigId int32) ApiDeleteBgpConfigRequest {
	return ApiDeleteBgpConfigRequest{
		ApiService: a,
		ctx: ctx,
		bgpConfigId: bgpConfigId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteBgpConfigExecute(r ApiDeleteBgpConfigRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteBgpConfig")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bgp-configs/{bgpConfigId}"
	localVarPath = strings.Replace(localVarPath, "{"+"bgpConfigId"+"}", _neturl.PathEscape(parameterToString(r.bgpConfigId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteGeoIpConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	geoIpConfigId int32
}


func (r ApiDeleteGeoIpConfigRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteGeoIpConfigExecute(r)
}

/*
DeleteGeoIpConfig GeoIpConfig Instance.

Remove a GeoIP configuration: This operation removes a GeoIP configuration instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param geoIpConfigId Uniquely identifies a GeoIP configuration instance. 
 @return ApiDeleteGeoIpConfigRequest
*/
func (a *DefaultApiService) DeleteGeoIpConfig(ctx _context.Context, geoIpConfigId int32) ApiDeleteGeoIpConfigRequest {
	return ApiDeleteGeoIpConfigRequest{
		ApiService: a,
		ctx: ctx,
		geoIpConfigId: geoIpConfigId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteGeoIpConfigExecute(r ApiDeleteGeoIpConfigRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteGeoIpConfig")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/geoip-configs/{geoIpConfigId}"
	localVarPath = strings.Replace(localVarPath, "{"+"geoIpConfigId"+"}", _neturl.PathEscape(parameterToString(r.geoIpConfigId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSiteMapRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	mapId int32
}


func (r ApiDeleteSiteMapRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteSiteMapExecute(r)
}

/*
DeleteSiteMap SiteMap Instance.

Remove a site map: This operation removes a site map instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapId Uniquely identifies a site map instance. 
 @return ApiDeleteSiteMapRequest
*/
func (a *DefaultApiService) DeleteSiteMap(ctx _context.Context, mapId int32) ApiDeleteSiteMapRequest {
	return ApiDeleteSiteMapRequest{
		ApiService: a,
		ctx: ctx,
		mapId: mapId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSiteMapExecute(r ApiDeleteSiteMapRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSiteMap")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/site-maps/{mapId}"
	localVarPath = strings.Replace(localVarPath, "{"+"mapId"+"}", _neturl.PathEscape(parameterToString(r.mapId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListAccessMapsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// The &#x60;view&#x60; parameter may be used to request that either the summary or detailed view be returned.
func (r ApiListAccessMapsRequest) View(view string) ApiListAccessMapsRequest {
	r.view = &view
	return r
}
// The &#x60;filter&#x60; parameter may be used to filter the returned collection.
func (r ApiListAccessMapsRequest) Filter(filter string) ApiListAccessMapsRequest {
	r.filter = &filter
	return r
}
// The &#x60;sortBy&#x60; parameter may be used to specify the sort order of the returned collection.
func (r ApiListAccessMapsRequest) SortBy(sortBy string) ApiListAccessMapsRequest {
	r.sortBy = &sortBy
	return r
}
// The &#x60;pageNumber&#x60; parameter may be used to specify an offset into the results.  Useful to use in conjunction with &#x60;pageSize&#x60;.  Page number offset is 1-based.
func (r ApiListAccessMapsRequest) PageNumber(pageNumber int32) ApiListAccessMapsRequest {
	r.pageNumber = &pageNumber
	return r
}
// The &#x60;pageSize&#x60; parameter may be used to specify the returned results.  Useful to use in conjunction with &#x60;pageNumber&#x60;.
func (r ApiListAccessMapsRequest) PageSize(pageSize int32) ApiListAccessMapsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListAccessMapsRequest) Execute() (AccessMapCollection, *_nethttp.Response, error) {
	return r.ApiService.ListAccessMapsExecute(r)
}

/*
ListAccessMaps AccessMap collection

List access maps: This operation returns a list of all configured access maps.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAccessMapsRequest
*/
func (a *DefaultApiService) ListAccessMaps(ctx _context.Context) ApiListAccessMapsRequest {
	return ApiListAccessMapsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AccessMapCollection
func (a *DefaultApiService) ListAccessMapsExecute(r ApiListAccessMapsRequest) (AccessMapCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccessMapCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListAccessMaps")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access-maps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListBgpConfigsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// The &#x60;view&#x60; parameter may be used to request that either the summary or detailed view be returned.
func (r ApiListBgpConfigsRequest) View(view string) ApiListBgpConfigsRequest {
	r.view = &view
	return r
}
// The &#x60;filter&#x60; parameter may be used to filter the returned collection.
func (r ApiListBgpConfigsRequest) Filter(filter string) ApiListBgpConfigsRequest {
	r.filter = &filter
	return r
}
// The &#x60;sortBy&#x60; parameter may be used to specify the sort order of the returned collection.
func (r ApiListBgpConfigsRequest) SortBy(sortBy string) ApiListBgpConfigsRequest {
	r.sortBy = &sortBy
	return r
}
// The &#x60;pageNumber&#x60; parameter may be used to specify an offset into the results.  Useful to use in conjunction with &#x60;pageSize&#x60;.  Page number offset is 1-based.
func (r ApiListBgpConfigsRequest) PageNumber(pageNumber int32) ApiListBgpConfigsRequest {
	r.pageNumber = &pageNumber
	return r
}
// The &#x60;pageSize&#x60; parameter may be used to specify the returned results.  Useful to use in conjunction with &#x60;pageNumber&#x60;.
func (r ApiListBgpConfigsRequest) PageSize(pageSize int32) ApiListBgpConfigsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListBgpConfigsRequest) Execute() (BgpConfigCollection, *_nethttp.Response, error) {
	return r.ApiService.ListBgpConfigsExecute(r)
}

/*
ListBgpConfigs BgpConfig collection

List BGP configurations: This operation returns a list of all BGP configurations.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListBgpConfigsRequest
*/
func (a *DefaultApiService) ListBgpConfigs(ctx _context.Context) ApiListBgpConfigsRequest {
	return ApiListBgpConfigsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BgpConfigCollection
func (a *DefaultApiService) ListBgpConfigsExecute(r ApiListBgpConfigsRequest) (BgpConfigCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BgpConfigCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListBgpConfigs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bgp-configs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListGeoIpConfigsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// The &#x60;view&#x60; parameter may be used to request that either the summary or detailed view be returned.
func (r ApiListGeoIpConfigsRequest) View(view string) ApiListGeoIpConfigsRequest {
	r.view = &view
	return r
}
// The &#x60;filter&#x60; parameter may be used to filter the returned collection.
func (r ApiListGeoIpConfigsRequest) Filter(filter string) ApiListGeoIpConfigsRequest {
	r.filter = &filter
	return r
}
// The &#x60;sortBy&#x60; parameter may be used to specify the sort order of the returned collection.
func (r ApiListGeoIpConfigsRequest) SortBy(sortBy string) ApiListGeoIpConfigsRequest {
	r.sortBy = &sortBy
	return r
}
// The &#x60;pageNumber&#x60; parameter may be used to specify an offset into the results.  Useful to use in conjunction with &#x60;pageSize&#x60;.  Page number offset is 1-based.
func (r ApiListGeoIpConfigsRequest) PageNumber(pageNumber int32) ApiListGeoIpConfigsRequest {
	r.pageNumber = &pageNumber
	return r
}
// The &#x60;pageSize&#x60; parameter may be used to specify the returned results.  Useful to use in conjunction with &#x60;pageNumber&#x60;.
func (r ApiListGeoIpConfigsRequest) PageSize(pageSize int32) ApiListGeoIpConfigsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListGeoIpConfigsRequest) Execute() (GeoipConfigCollection, *_nethttp.Response, error) {
	return r.ApiService.ListGeoIpConfigsExecute(r)
}

/*
ListGeoIpConfigs GeoIpConfig collection

List GeoIP configurations: This operation returns a list of all GeoIP configurations.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListGeoIpConfigsRequest
*/
func (a *DefaultApiService) ListGeoIpConfigs(ctx _context.Context) ApiListGeoIpConfigsRequest {
	return ApiListGeoIpConfigsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GeoipConfigCollection
func (a *DefaultApiService) ListGeoIpConfigsExecute(r ApiListGeoIpConfigsRequest) (GeoipConfigCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GeoipConfigCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListGeoIpConfigs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/geoip-configs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSiteMapsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// The &#x60;view&#x60; parameter may be used to request that either the summary or detailed view be returned.
func (r ApiListSiteMapsRequest) View(view string) ApiListSiteMapsRequest {
	r.view = &view
	return r
}
// The &#x60;filter&#x60; parameter may be used to filter the returned collection.
func (r ApiListSiteMapsRequest) Filter(filter string) ApiListSiteMapsRequest {
	r.filter = &filter
	return r
}
// The &#x60;sortBy&#x60; parameter may be used to specify the sort order of the returned collection.
func (r ApiListSiteMapsRequest) SortBy(sortBy string) ApiListSiteMapsRequest {
	r.sortBy = &sortBy
	return r
}
// The &#x60;pageNumber&#x60; parameter may be used to specify an offset into the results.  Useful to use in conjunction with &#x60;pageSize&#x60;.  Page number offset is 1-based.
func (r ApiListSiteMapsRequest) PageNumber(pageNumber int32) ApiListSiteMapsRequest {
	r.pageNumber = &pageNumber
	return r
}
// The &#x60;pageSize&#x60; parameter may be used to specify the returned results.  Useful to use in conjunction with &#x60;pageNumber&#x60;.
func (r ApiListSiteMapsRequest) PageSize(pageSize int32) ApiListSiteMapsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListSiteMapsRequest) Execute() (SiteMapCollection, *_nethttp.Response, error) {
	return r.ApiService.ListSiteMapsExecute(r)
}

/*
ListSiteMaps SiteMap collection

List site maps: This operation returns a list of all configured site maps.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSiteMapsRequest
*/
func (a *DefaultApiService) ListSiteMaps(ctx _context.Context) ApiListSiteMapsRequest {
	return ApiListSiteMapsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SiteMapCollection
func (a *DefaultApiService) ListSiteMapsExecute(r ApiListSiteMapsRequest) (SiteMapCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SiteMapCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSiteMaps")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/site-maps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadAccessMapRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	mapId int32
}


func (r ApiReadAccessMapRequest) Execute() (AccessMapReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.ReadAccessMapExecute(r)
}

/*
ReadAccessMap AccessMap Instance.

Get an access map: This operation gets the details of an access map instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapId Uniquely identifies an access map instance. 
 @return ApiReadAccessMapRequest
*/
func (a *DefaultApiService) ReadAccessMap(ctx _context.Context, mapId int32) ApiReadAccessMapRequest {
	return ApiReadAccessMapRequest{
		ApiService: a,
		ctx: ctx,
		mapId: mapId,
	}
}

// Execute executes the request
//  @return AccessMapReadDetailed
func (a *DefaultApiService) ReadAccessMapExecute(r ApiReadAccessMapRequest) (AccessMapReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccessMapReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadAccessMap")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access-maps/{mapId}"
	localVarPath = strings.Replace(localVarPath, "{"+"mapId"+"}", _neturl.PathEscape(parameterToString(r.mapId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadAccessMapContentRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	mapId int32
}


func (r ApiReadAccessMapContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ReadAccessMapContentExecute(r)
}

/*
ReadAccessMapContent AccessMap Instance Map Content.

Get a access map content: This operation gets the details of a access map instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapId Uniquely identifies an access map instance. 
 @return ApiReadAccessMapContentRequest
*/
func (a *DefaultApiService) ReadAccessMapContent(ctx _context.Context, mapId int32) ApiReadAccessMapContentRequest {
	return ApiReadAccessMapContentRequest{
		ApiService: a,
		ctx: ctx,
		mapId: mapId,
	}
}

// Execute executes the request
func (a *DefaultApiService) ReadAccessMapContentExecute(r ApiReadAccessMapContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadAccessMapContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access-maps/{mapId}/map"
	localVarPath = strings.Replace(localVarPath, "{"+"mapId"+"}", _neturl.PathEscape(parameterToString(r.mapId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReadBgpConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	bgpConfigId int32
}


func (r ApiReadBgpConfigRequest) Execute() (BgpConfigReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.ReadBgpConfigExecute(r)
}

/*
ReadBgpConfig BgpConfig Instance.

Get a BGP configuration: This operation gets the details of a BGP configuration instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bgpConfigId Uniquely identifies a BGP configuration instance. 
 @return ApiReadBgpConfigRequest
*/
func (a *DefaultApiService) ReadBgpConfig(ctx _context.Context, bgpConfigId int32) ApiReadBgpConfigRequest {
	return ApiReadBgpConfigRequest{
		ApiService: a,
		ctx: ctx,
		bgpConfigId: bgpConfigId,
	}
}

// Execute executes the request
//  @return BgpConfigReadDetailed
func (a *DefaultApiService) ReadBgpConfigExecute(r ApiReadBgpConfigRequest) (BgpConfigReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BgpConfigReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadBgpConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bgp-configs/{bgpConfigId}"
	localVarPath = strings.Replace(localVarPath, "{"+"bgpConfigId"+"}", _neturl.PathEscape(parameterToString(r.bgpConfigId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadBgpConfigContentRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	bgpConfigId int32
}


func (r ApiReadBgpConfigContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ReadBgpConfigContentExecute(r)
}

/*
ReadBgpConfigContent BgpConfig Instance BGP configuration.

Get a BGP config content: This operation gets the details of a BGP configuration.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bgpConfigId Uniquely identifies a BGP configuration instance. 
 @return ApiReadBgpConfigContentRequest
*/
func (a *DefaultApiService) ReadBgpConfigContent(ctx _context.Context, bgpConfigId int32) ApiReadBgpConfigContentRequest {
	return ApiReadBgpConfigContentRequest{
		ApiService: a,
		ctx: ctx,
		bgpConfigId: bgpConfigId,
	}
}

// Execute executes the request
func (a *DefaultApiService) ReadBgpConfigContentExecute(r ApiReadBgpConfigContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadBgpConfigContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bgp-configs/{bgpConfigId}/bgp-config"
	localVarPath = strings.Replace(localVarPath, "{"+"bgpConfigId"+"}", _neturl.PathEscape(parameterToString(r.bgpConfigId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReadGeoIpConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	geoIpConfigId int32
}


func (r ApiReadGeoIpConfigRequest) Execute() (GeoipConfigReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.ReadGeoIpConfigExecute(r)
}

/*
ReadGeoIpConfig GeoIpConfig Instance.

Get a GeoIP configuration: This operation retrieves the details of a GeoIP configuration instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param geoIpConfigId Uniquely identifies a GeoIP configuration instance. 
 @return ApiReadGeoIpConfigRequest
*/
func (a *DefaultApiService) ReadGeoIpConfig(ctx _context.Context, geoIpConfigId int32) ApiReadGeoIpConfigRequest {
	return ApiReadGeoIpConfigRequest{
		ApiService: a,
		ctx: ctx,
		geoIpConfigId: geoIpConfigId,
	}
}

// Execute executes the request
//  @return GeoipConfigReadDetailed
func (a *DefaultApiService) ReadGeoIpConfigExecute(r ApiReadGeoIpConfigRequest) (GeoipConfigReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GeoipConfigReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadGeoIpConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/geoip-configs/{geoIpConfigId}"
	localVarPath = strings.Replace(localVarPath, "{"+"geoIpConfigId"+"}", _neturl.PathEscape(parameterToString(r.geoIpConfigId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadGeoIpConfigContentRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	geoIpConfigId int32
}


func (r ApiReadGeoIpConfigContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ReadGeoIpConfigContentExecute(r)
}

/*
ReadGeoIpConfigContent GeoIpConfig Instance GeoIP configuration.

Get a GeoIP config content: This operation gets the details of a GeoIP configuration.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param geoIpConfigId Uniquely identifies a GeoIP configuration instance. 
 @return ApiReadGeoIpConfigContentRequest
*/
func (a *DefaultApiService) ReadGeoIpConfigContent(ctx _context.Context, geoIpConfigId int32) ApiReadGeoIpConfigContentRequest {
	return ApiReadGeoIpConfigContentRequest{
		ApiService: a,
		ctx: ctx,
		geoIpConfigId: geoIpConfigId,
	}
}

// Execute executes the request
func (a *DefaultApiService) ReadGeoIpConfigContentExecute(r ApiReadGeoIpConfigContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadGeoIpConfigContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/geoip-configs/{geoIpConfigId}/geoip-config"
	localVarPath = strings.Replace(localVarPath, "{"+"geoIpConfigId"+"}", _neturl.PathEscape(parameterToString(r.geoIpConfigId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReadSiteMapRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	mapId int32
}


func (r ApiReadSiteMapRequest) Execute() (SiteMapReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.ReadSiteMapExecute(r)
}

/*
ReadSiteMap SiteMap Instance.

Get a site map: This operation gets the details of a site map instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapId Uniquely identifies a site map instance. 
 @return ApiReadSiteMapRequest
*/
func (a *DefaultApiService) ReadSiteMap(ctx _context.Context, mapId int32) ApiReadSiteMapRequest {
	return ApiReadSiteMapRequest{
		ApiService: a,
		ctx: ctx,
		mapId: mapId,
	}
}

// Execute executes the request
//  @return SiteMapReadDetailed
func (a *DefaultApiService) ReadSiteMapExecute(r ApiReadSiteMapRequest) (SiteMapReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SiteMapReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadSiteMap")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/site-maps/{mapId}"
	localVarPath = strings.Replace(localVarPath, "{"+"mapId"+"}", _neturl.PathEscape(parameterToString(r.mapId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadSiteMapContentRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	mapId int32
}


func (r ApiReadSiteMapContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ReadSiteMapContentExecute(r)
}

/*
ReadSiteMapContent SiteMap Instance Map Content.

Get a site map content: This operation gets the content of a site map instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapId Uniquely identifies a site map instance. 
 @return ApiReadSiteMapContentRequest
*/
func (a *DefaultApiService) ReadSiteMapContent(ctx _context.Context, mapId int32) ApiReadSiteMapContentRequest {
	return ApiReadSiteMapContentRequest{
		ApiService: a,
		ctx: ctx,
		mapId: mapId,
	}
}

// Execute executes the request
func (a *DefaultApiService) ReadSiteMapContentExecute(r ApiReadSiteMapContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadSiteMapContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/site-maps/{mapId}/map"
	localVarPath = strings.Replace(localVarPath, "{"+"mapId"+"}", _neturl.PathEscape(parameterToString(r.mapId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateAccessMapRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	mapId int32
	accessMapUpdate *AccessMapUpdate
}

func (r ApiUpdateAccessMapRequest) AccessMapUpdate(accessMapUpdate AccessMapUpdate) ApiUpdateAccessMapRequest {
	r.accessMapUpdate = &accessMapUpdate
	return r
}

func (r ApiUpdateAccessMapRequest) Execute() (AccessMapReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.UpdateAccessMapExecute(r)
}

/*
UpdateAccessMap AccessMap Instance.

Update an access map: This operation updates the details of an access map instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapId Uniquely identifies an access map instance. 
 @return ApiUpdateAccessMapRequest
*/
func (a *DefaultApiService) UpdateAccessMap(ctx _context.Context, mapId int32) ApiUpdateAccessMapRequest {
	return ApiUpdateAccessMapRequest{
		ApiService: a,
		ctx: ctx,
		mapId: mapId,
	}
}

// Execute executes the request
//  @return AccessMapReadDetailed
func (a *DefaultApiService) UpdateAccessMapExecute(r ApiUpdateAccessMapRequest) (AccessMapReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AccessMapReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateAccessMap")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access-maps/{mapId}"
	localVarPath = strings.Replace(localVarPath, "{"+"mapId"+"}", _neturl.PathEscape(parameterToString(r.mapId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.accessMapUpdate == nil {
		return localVarReturnValue, nil, reportError("accessMapUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.accessMapUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAccessMapContentRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	mapId int32
	body *string
}

func (r ApiUpdateAccessMapContentRequest) Body(body string) ApiUpdateAccessMapContentRequest {
	r.body = &body
	return r
}

func (r ApiUpdateAccessMapContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateAccessMapContentExecute(r)
}

/*
UpdateAccessMapContent AccessMap Instance Map Content.

Update a site map content: This operation updates the content of a site map instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapId Uniquely identifies an access map instance. 
 @return ApiUpdateAccessMapContentRequest
*/
func (a *DefaultApiService) UpdateAccessMapContent(ctx _context.Context, mapId int32) ApiUpdateAccessMapContentRequest {
	return ApiUpdateAccessMapContentRequest{
		ApiService: a,
		ctx: ctx,
		mapId: mapId,
	}
}

// Execute executes the request
func (a *DefaultApiService) UpdateAccessMapContentExecute(r ApiUpdateAccessMapContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateAccessMapContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access-maps/{mapId}/map"
	localVarPath = strings.Replace(localVarPath, "{"+"mapId"+"}", _neturl.PathEscape(parameterToString(r.mapId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateBgpConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	bgpConfigId int32
	bgpConfigUpdate *BgpConfigUpdate
}

func (r ApiUpdateBgpConfigRequest) BgpConfigUpdate(bgpConfigUpdate BgpConfigUpdate) ApiUpdateBgpConfigRequest {
	r.bgpConfigUpdate = &bgpConfigUpdate
	return r
}

func (r ApiUpdateBgpConfigRequest) Execute() (BgpConfigReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.UpdateBgpConfigExecute(r)
}

/*
UpdateBgpConfig BgpConfig Instance.

Update a BGP configuration: This operation updates the details of a BGP configuration instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bgpConfigId Uniquely identifies a BGP configuration instance. 
 @return ApiUpdateBgpConfigRequest
*/
func (a *DefaultApiService) UpdateBgpConfig(ctx _context.Context, bgpConfigId int32) ApiUpdateBgpConfigRequest {
	return ApiUpdateBgpConfigRequest{
		ApiService: a,
		ctx: ctx,
		bgpConfigId: bgpConfigId,
	}
}

// Execute executes the request
//  @return BgpConfigReadDetailed
func (a *DefaultApiService) UpdateBgpConfigExecute(r ApiUpdateBgpConfigRequest) (BgpConfigReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BgpConfigReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateBgpConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bgp-configs/{bgpConfigId}"
	localVarPath = strings.Replace(localVarPath, "{"+"bgpConfigId"+"}", _neturl.PathEscape(parameterToString(r.bgpConfigId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.bgpConfigUpdate == nil {
		return localVarReturnValue, nil, reportError("bgpConfigUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bgpConfigUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBgpConfigContentRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	bgpConfigId int32
	body *string
}

func (r ApiUpdateBgpConfigContentRequest) Body(body string) ApiUpdateBgpConfigContentRequest {
	r.body = &body
	return r
}

func (r ApiUpdateBgpConfigContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateBgpConfigContentExecute(r)
}

/*
UpdateBgpConfigContent BgpConfig Instance BGP configuration.

Update a BgpConfig Instance BGP configuration: This operation updates the content of a
BGP configuration.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param bgpConfigId Uniquely identifies a BGP configuration instance. 
 @return ApiUpdateBgpConfigContentRequest
*/
func (a *DefaultApiService) UpdateBgpConfigContent(ctx _context.Context, bgpConfigId int32) ApiUpdateBgpConfigContentRequest {
	return ApiUpdateBgpConfigContentRequest{
		ApiService: a,
		ctx: ctx,
		bgpConfigId: bgpConfigId,
	}
}

// Execute executes the request
func (a *DefaultApiService) UpdateBgpConfigContentExecute(r ApiUpdateBgpConfigContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateBgpConfigContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/bgp-configs/{bgpConfigId}/bgp-config"
	localVarPath = strings.Replace(localVarPath, "{"+"bgpConfigId"+"}", _neturl.PathEscape(parameterToString(r.bgpConfigId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateGeoIpConfigRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	geoIpConfigId int32
	geoipConfigUpdate *GeoipConfigUpdate
}

func (r ApiUpdateGeoIpConfigRequest) GeoipConfigUpdate(geoipConfigUpdate GeoipConfigUpdate) ApiUpdateGeoIpConfigRequest {
	r.geoipConfigUpdate = &geoipConfigUpdate
	return r
}

func (r ApiUpdateGeoIpConfigRequest) Execute() (GeoipConfigReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.UpdateGeoIpConfigExecute(r)
}

/*
UpdateGeoIpConfig GeoIpConfig Instance.

Update a GeoIP configuration: This operation updates the details of a GeoIP configuration instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param geoIpConfigId Uniquely identifies a GeoIP configuration instance. 
 @return ApiUpdateGeoIpConfigRequest
*/
func (a *DefaultApiService) UpdateGeoIpConfig(ctx _context.Context, geoIpConfigId int32) ApiUpdateGeoIpConfigRequest {
	return ApiUpdateGeoIpConfigRequest{
		ApiService: a,
		ctx: ctx,
		geoIpConfigId: geoIpConfigId,
	}
}

// Execute executes the request
//  @return GeoipConfigReadDetailed
func (a *DefaultApiService) UpdateGeoIpConfigExecute(r ApiUpdateGeoIpConfigRequest) (GeoipConfigReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GeoipConfigReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateGeoIpConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/geoip-configs/{geoIpConfigId}"
	localVarPath = strings.Replace(localVarPath, "{"+"geoIpConfigId"+"}", _neturl.PathEscape(parameterToString(r.geoIpConfigId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.geoipConfigUpdate == nil {
		return localVarReturnValue, nil, reportError("geoipConfigUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.geoipConfigUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateGeoIpConfigContentRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	geoIpConfigId int32
	body *string
}

func (r ApiUpdateGeoIpConfigContentRequest) Body(body string) ApiUpdateGeoIpConfigContentRequest {
	r.body = &body
	return r
}

func (r ApiUpdateGeoIpConfigContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateGeoIpConfigContentExecute(r)
}

/*
UpdateGeoIpConfigContent GeoIpConfig Instance GeoIP configuration.

Update a GeoIpConfig Instance GeoIP configuration: This operation updates the content of a
GeoIP configuration.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param geoIpConfigId Uniquely identifies a GeoIP configuration instance. 
 @return ApiUpdateGeoIpConfigContentRequest
*/
func (a *DefaultApiService) UpdateGeoIpConfigContent(ctx _context.Context, geoIpConfigId int32) ApiUpdateGeoIpConfigContentRequest {
	return ApiUpdateGeoIpConfigContentRequest{
		ApiService: a,
		ctx: ctx,
		geoIpConfigId: geoIpConfigId,
	}
}

// Execute executes the request
func (a *DefaultApiService) UpdateGeoIpConfigContentExecute(r ApiUpdateGeoIpConfigContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateGeoIpConfigContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/geoip-configs/{geoIpConfigId}/geoip-config"
	localVarPath = strings.Replace(localVarPath, "{"+"geoIpConfigId"+"}", _neturl.PathEscape(parameterToString(r.geoIpConfigId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/csv"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateSiteMapRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	mapId int32
	siteMapUpdate *SiteMapUpdate
}

func (r ApiUpdateSiteMapRequest) SiteMapUpdate(siteMapUpdate SiteMapUpdate) ApiUpdateSiteMapRequest {
	r.siteMapUpdate = &siteMapUpdate
	return r
}

func (r ApiUpdateSiteMapRequest) Execute() (SiteMapReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.UpdateSiteMapExecute(r)
}

/*
UpdateSiteMap SiteMap Instance.

Update a site map: This operation updates the details of a site map instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapId Uniquely identifies a site map instance. 
 @return ApiUpdateSiteMapRequest
*/
func (a *DefaultApiService) UpdateSiteMap(ctx _context.Context, mapId int32) ApiUpdateSiteMapRequest {
	return ApiUpdateSiteMapRequest{
		ApiService: a,
		ctx: ctx,
		mapId: mapId,
	}
}

// Execute executes the request
//  @return SiteMapReadDetailed
func (a *DefaultApiService) UpdateSiteMapExecute(r ApiUpdateSiteMapRequest) (SiteMapReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SiteMapReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSiteMap")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/site-maps/{mapId}"
	localVarPath = strings.Replace(localVarPath, "{"+"mapId"+"}", _neturl.PathEscape(parameterToString(r.mapId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.siteMapUpdate == nil {
		return localVarReturnValue, nil, reportError("siteMapUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.siteMapUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSiteMapContentRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	mapId int32
	body *string
}

func (r ApiUpdateSiteMapContentRequest) Body(body string) ApiUpdateSiteMapContentRequest {
	r.body = &body
	return r
}

func (r ApiUpdateSiteMapContentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateSiteMapContentExecute(r)
}

/*
UpdateSiteMapContent SiteMap Instance Map Content.

Update a site map content: This operation updates the content of a site map instance.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param mapId Uniquely identifies a site map instance. 
 @return ApiUpdateSiteMapContentRequest
*/
func (a *DefaultApiService) UpdateSiteMapContent(ctx _context.Context, mapId int32) ApiUpdateSiteMapContentRequest {
	return ApiUpdateSiteMapContentRequest{
		ApiService: a,
		ctx: ctx,
		mapId: mapId,
	}
}

// Execute executes the request
func (a *DefaultApiService) UpdateSiteMapContentExecute(r ApiUpdateSiteMapContentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSiteMapContent")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/site-maps/{mapId}/map"
	localVarPath = strings.Replace(localVarPath, "{"+"mapId"+"}", _neturl.PathEscape(parameterToString(r.mapId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"text/plain"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidateAccessMapRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	metadata *AccessMapCreate
	config *interface{}
}

func (r ApiValidateAccessMapRequest) Metadata(metadata AccessMapCreate) ApiValidateAccessMapRequest {
	r.metadata = &metadata
	return r
}
func (r ApiValidateAccessMapRequest) Config(config interface{}) ApiValidateAccessMapRequest {
	r.config = &config
	return r
}

func (r ApiValidateAccessMapRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ValidateAccessMapExecute(r)
}

/*
ValidateAccessMap /validate

Validate an access map: This operation validates an Access Map, and may be used to ensure
correct syntax when preparing to apply a map.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateAccessMapRequest
*/
func (a *DefaultApiService) ValidateAccessMap(ctx _context.Context) ApiValidateAccessMapRequest {
	return ApiValidateAccessMapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) ValidateAccessMapExecute(r ApiValidateAccessMapRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ValidateAccessMap")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/access-maps/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.metadata != nil {
		paramJson, err := parameterToJson(*r.metadata)
		if err != nil {
			return nil, err
		}
		localVarFormParams.Add("metadata", paramJson)
	}
	if r.config != nil {
		localVarFormParams.Add("config", parameterToString(*r.config, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidateSiteMapRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	metadata *SiteMapCreate
	config *interface{}
}

func (r ApiValidateSiteMapRequest) Metadata(metadata SiteMapCreate) ApiValidateSiteMapRequest {
	r.metadata = &metadata
	return r
}
func (r ApiValidateSiteMapRequest) Config(config interface{}) ApiValidateSiteMapRequest {
	r.config = &config
	return r
}

func (r ApiValidateSiteMapRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ValidateSiteMapExecute(r)
}

/*
ValidateSiteMap /validate

Validates a site map: This operation validates a site map, and may be used to ensure correct syntax when preparing to apply a map.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateSiteMapRequest
*/
func (a *DefaultApiService) ValidateSiteMap(ctx _context.Context) ApiValidateSiteMapRequest {
	return ApiValidateSiteMapRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) ValidateSiteMapExecute(r ApiValidateSiteMapRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ValidateSiteMap")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/site-maps/validate"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.metadata != nil {
		paramJson, err := parameterToJson(*r.metadata)
		if err != nil {
			return nil, err
		}
		localVarFormParams.Add("metadata", paramJson)
	}
	if r.config != nil {
		localVarFormParams.Add("config", parameterToString(*r.config, ""))
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
