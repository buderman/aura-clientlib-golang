/*
content-delivery

Aura LCDN Content Delivery API

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package content_delivery

import (
	"encoding/json"
	"fmt"
)

// CachingType Determines whether to validate requests for cached content with the origin server. With default `OPTIMISTIC` caching, the HyperCache serves cached content without validating the content with the origin server, unless the content is expired. With `CONSERVATIVE` caching, every cache request is validated with the origin server by sending an HTTP HEAD request. If the content is stale, the HyperCache node gets the new content from the origin server. The old content ages out of the cache.
type CachingType string

// List of cachingType
const (
	CACHINGTYPE_CONSERVATIVE CachingType = "CONSERVATIVE"
	CACHINGTYPE_OPTIMISTIC CachingType = "OPTIMISTIC"
)

// All allowed values of CachingType enum
var AllowedCachingTypeEnumValues = []CachingType{
	"CONSERVATIVE",
	"OPTIMISTIC",
}

func (v *CachingType) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := CachingType(value)
	for _, existing := range AllowedCachingTypeEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid CachingType", value)
}

// NewCachingTypeFromValue returns a pointer to a valid CachingType
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewCachingTypeFromValue(v string) (*CachingType, error) {
	ev := CachingType(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for CachingType: valid values are %v", v, AllowedCachingTypeEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v CachingType) IsValid() bool {
	for _, existing := range AllowedCachingTypeEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to cachingType value
func (v CachingType) Ptr() *CachingType {
	return &v
}

type NullableCachingType struct {
	value *CachingType
	isSet bool
}

func (v NullableCachingType) Get() *CachingType {
	return v.value
}

func (v *NullableCachingType) Set(val *CachingType) {
	v.value = val
	v.isSet = true
}

func (v NullableCachingType) IsSet() bool {
	return v.isSet
}

func (v *NullableCachingType) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableCachingType(val *CachingType) *NullableCachingType {
	return &NullableCachingType{value: val, isSet: true}
}

func (v NullableCachingType) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableCachingType) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

