/*
content-delivery

Aura LCDN Content Delivery API

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package content_delivery

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type DefaultApi interface {

	/*
	CreateCdnPrefix cdn prefixes

	Create a New CDN prefix: This operation creates a new CDN
prefix. A CDN prefix is a defined hostname which is referenced
by an end user's request for content. This is accomplished using
a DNS lookup directed to a node running the request router service.
The request router then determines the HPC node best able to serve
that particular end user's request.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @return ApiCreateCdnPrefixRequest
	*/
	CreateCdnPrefix(ctx _context.Context, contentProviderId int32) ApiCreateCdnPrefixRequest

	// CreateCdnPrefixExecute executes the request
	//  @return CdnPrefixReadDetailed
	CreateCdnPrefixExecute(r ApiCreateCdnPrefixRequest) (CdnPrefixReadDetailed, *_nethttp.Response, error)

	/*
	CreateOrigin origins

	Create a new origin: This operation allows a service provider to
register a new URL for each origin server that a content
provider wants to add to the CDN.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @return ApiCreateOriginRequest
	*/
	CreateOrigin(ctx _context.Context, contentProviderId int32) ApiCreateOriginRequest

	// CreateOriginExecute executes the request
	//  @return OriginReadDetailed
	CreateOriginExecute(r ApiCreateOriginRequest) (OriginReadDetailed, *_nethttp.Response, error)

	/*
	CreateSharedSecretSet shared secret sets

	Create a new shared secret set: This operation creates a new
shared secret set for the specified content provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @return ApiCreateSharedSecretSetRequest
	*/
	CreateSharedSecretSet(ctx _context.Context, contentProviderId int32) ApiCreateSharedSecretSetRequest

	// CreateSharedSecretSetExecute executes the request
	//  @return SharedSecretSetReadDetailed
	CreateSharedSecretSetExecute(r ApiCreateSharedSecretSetRequest) (SharedSecretSetReadDetailed, *_nethttp.Response, error)

	/*
	CreateTlsDeliveryProfile tls delivery profiles

	Create a new TLS delivery profile: This operation creates a new
content provider TLS delivery profile. The content provider TLS
delivery profile specifies the security settings used for TLS
connections when a content provider wants content delivered over
HTTPS. This type of profile is created by the content provider,
and its available for use by CDN prefixes owned by that content
provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @return ApiCreateTlsDeliveryProfileRequest
	*/
	CreateTlsDeliveryProfile(ctx _context.Context, contentProviderId int32) ApiCreateTlsDeliveryProfileRequest

	// CreateTlsDeliveryProfileExecute executes the request
	//  @return TlsDeliveryProfileReadDetailed
	CreateTlsDeliveryProfileExecute(r ApiCreateTlsDeliveryProfileRequest) (TlsDeliveryProfileReadDetailed, *_nethttp.Response, error)

	/*
	CreateTlsIngestProfiles tls ingest profiles

	Create a new TLS ingest profile: This operation creates a TLS
ingest profile. To configure the ingest of content from an
origin over HTTPS, a content provider must first create a TLS
ingest profile and bind the profile to the origin. The
HyperCache uses the TLS parameters specified in the TLS ingest
profile to ingest content from the origin. A TLS ingest profile
can be bound to one or more origins, and can only be deleted if
it is not bound to an origin.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @return ApiCreateTlsIngestProfilesRequest
	*/
	CreateTlsIngestProfiles(ctx _context.Context, contentProviderId int32) ApiCreateTlsIngestProfilesRequest

	// CreateTlsIngestProfilesExecute executes the request
	//  @return TlsIngestProfileReadDetailed
	CreateTlsIngestProfilesExecute(r ApiCreateTlsIngestProfilesRequest) (TlsIngestProfileReadDetailed, *_nethttp.Response, error)

	/*
	DeleteCdnPrefix cdn prefix

	Delete a CDN prefix: This operation deletes a CDN prefix.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param cdnPrefixId Unique identifier for each CDN prefix. 
	 @return ApiDeleteCdnPrefixRequest
	*/
	DeleteCdnPrefix(ctx _context.Context, contentProviderId int32, cdnPrefixId int32) ApiDeleteCdnPrefixRequest

	// DeleteCdnPrefixExecute executes the request
	DeleteCdnPrefixExecute(r ApiDeleteCdnPrefixRequest) (*_nethttp.Response, error)

	/*
	DeleteOrigin origin

	Delete an origin: This operation removes the association of an
origin server from the specified content provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param originId Unique identifier for each origin. 
	 @return ApiDeleteOriginRequest
	*/
	DeleteOrigin(ctx _context.Context, contentProviderId int32, originId int32) ApiDeleteOriginRequest

	// DeleteOriginExecute executes the request
	DeleteOriginExecute(r ApiDeleteOriginRequest) (*_nethttp.Response, error)

	/*
	DeleteSharedSecretSet shared secret set

	Delete a shared secret: This operation deletes a shared secret
set for a specified content provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param sharedSecretSetId Unique identifier for each shared secret set. 
	 @return ApiDeleteSharedSecretSetRequest
	*/
	DeleteSharedSecretSet(ctx _context.Context, contentProviderId int32, sharedSecretSetId int32) ApiDeleteSharedSecretSetRequest

	// DeleteSharedSecretSetExecute executes the request
	DeleteSharedSecretSetExecute(r ApiDeleteSharedSecretSetRequest) (*_nethttp.Response, error)

	/*
	DeleteTlsDeliveryProfile tls delivery profile

	Delete a TLS delivery profile: This operation deletes a TLS
delivery profile for the specified content provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param tlsDeliveryProfileId Unique identifier for each TLS delivery profile. 
	 @return ApiDeleteTlsDeliveryProfileRequest
	*/
	DeleteTlsDeliveryProfile(ctx _context.Context, contentProviderId int32, tlsDeliveryProfileId int32) ApiDeleteTlsDeliveryProfileRequest

	// DeleteTlsDeliveryProfileExecute executes the request
	DeleteTlsDeliveryProfileExecute(r ApiDeleteTlsDeliveryProfileRequest) (*_nethttp.Response, error)

	/*
	DeleteTlsIngestProfile tls ingest profile

	Delete a TLS ingest profile: This operation deletes a TLS
ingest profile for the specified content provider. A TLS
ingest profile can be bound to one or more origins, and can
only be deleted if it is not bound to an origin.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param tlsIngestProfileId Unique identifier for each TLS ingest profile. 
	 @return ApiDeleteTlsIngestProfileRequest
	*/
	DeleteTlsIngestProfile(ctx _context.Context, contentProviderId int32, tlsIngestProfileId int32) ApiDeleteTlsIngestProfileRequest

	// DeleteTlsIngestProfileExecute executes the request
	DeleteTlsIngestProfileExecute(r ApiDeleteTlsIngestProfileRequest) (*_nethttp.Response, error)

	/*
	ListCdnPrefixes cdn prefixes

	List CDN prefixes: This operation provides a list of the CDN
prefixes owned by the content provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @return ApiListCdnPrefixesRequest
	*/
	ListCdnPrefixes(ctx _context.Context, contentProviderId int32) ApiListCdnPrefixesRequest

	// ListCdnPrefixesExecute executes the request
	//  @return CdnPrefixCollection
	ListCdnPrefixesExecute(r ApiListCdnPrefixesRequest) (CdnPrefixCollection, *_nethttp.Response, error)

	/*
	ListContentProviders content providers

	List Content Providers: This operation provides a list of Content Providers
accessible to the principal. For Operators, all Content Providers in the system
are returned. For Content Provider users, only the Content Providers that are
associated with that user are returned. For Service Provider users, all Content
Providers associated with that user and with that Service Provider are returned.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListContentProvidersRequest
	*/
	ListContentProviders(ctx _context.Context) ApiListContentProvidersRequest

	// ListContentProvidersExecute executes the request
	//  @return ContentProviderCollection
	ListContentProvidersExecute(r ApiListContentProvidersRequest) (ContentProviderCollection, *_nethttp.Response, error)

	/*
	ListOrigins origins

	List origins: This operation displays the origins owned by the
Content Provider specified by `contentProviderId`.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @return ApiListOriginsRequest
	*/
	ListOrigins(ctx _context.Context, contentProviderId int32) ApiListOriginsRequest

	// ListOriginsExecute executes the request
	//  @return OriginCollection
	ListOriginsExecute(r ApiListOriginsRequest) (OriginCollection, *_nethttp.Response, error)

	/*
	ListSharedSecretSets shared secret sets

	List shared secret sets: This operation lists all shared secrets
sets for a specified content provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @return ApiListSharedSecretSetsRequest
	*/
	ListSharedSecretSets(ctx _context.Context, contentProviderId int32) ApiListSharedSecretSetsRequest

	// ListSharedSecretSetsExecute executes the request
	//  @return SharedSecretSetCollection
	ListSharedSecretSetsExecute(r ApiListSharedSecretSetsRequest) (SharedSecretSetCollection, *_nethttp.Response, error)

	/*
	ListTlsDeliveryProfileCdnPrefixes cdn prefixes per tls

	List CDN prefixes for a TLS delivery profile: This operation
displays the list of CDN prefixes for the specified TLS
delivery profile.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param tlsDeliveryProfileId Unique identifier for each TLS delivery profile. 
	 @return ApiListTlsDeliveryProfileCdnPrefixesRequest
	*/
	ListTlsDeliveryProfileCdnPrefixes(ctx _context.Context, contentProviderId int32, tlsDeliveryProfileId int32) ApiListTlsDeliveryProfileCdnPrefixesRequest

	// ListTlsDeliveryProfileCdnPrefixesExecute executes the request
	//  @return CdnPrefixCollection
	ListTlsDeliveryProfileCdnPrefixesExecute(r ApiListTlsDeliveryProfileCdnPrefixesRequest) (CdnPrefixCollection, *_nethttp.Response, error)

	/*
	ListTlsDeliveryProfiles tls delivery profiles

	List TLS delivery profiles: This operation lists the TLS
delivery profiles owned by the specified content provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @return ApiListTlsDeliveryProfilesRequest
	*/
	ListTlsDeliveryProfiles(ctx _context.Context, contentProviderId int32) ApiListTlsDeliveryProfilesRequest

	// ListTlsDeliveryProfilesExecute executes the request
	//  @return TlsDeliveryProfileCollection
	ListTlsDeliveryProfilesExecute(r ApiListTlsDeliveryProfilesRequest) (TlsDeliveryProfileCollection, *_nethttp.Response, error)

	/*
	ListTlsIngestProfileOrigins origin per tls ingest profile

	List origins for a TLS delivery profile: This operation
lists the origins associated with a specified TLS delivery
profile.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param tlsIngestProfileId Unique identifier for each TLS ingest profile. 
	 @return ApiListTlsIngestProfileOriginsRequest
	*/
	ListTlsIngestProfileOrigins(ctx _context.Context, contentProviderId int32, tlsIngestProfileId int32) ApiListTlsIngestProfileOriginsRequest

	// ListTlsIngestProfileOriginsExecute executes the request
	//  @return OriginCollection
	ListTlsIngestProfileOriginsExecute(r ApiListTlsIngestProfileOriginsRequest) (OriginCollection, *_nethttp.Response, error)

	/*
	ListTlsIngestProfiles tls ingest profiles

	List TLS ingest profiles: This operation displays the list of
TLS ingest profiles owned by the specified content provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @return ApiListTlsIngestProfilesRequest
	*/
	ListTlsIngestProfiles(ctx _context.Context, contentProviderId int32) ApiListTlsIngestProfilesRequest

	// ListTlsIngestProfilesExecute executes the request
	//  @return TlsIngestProfileCollection
	ListTlsIngestProfilesExecute(r ApiListTlsIngestProfilesRequest) (TlsIngestProfileCollection, *_nethttp.Response, error)

	/*
	ReadCdnPrefix cdn prefix

	Get a CDN prefix: This operation provides a list of the CDN prefixes.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param cdnPrefixId Unique identifier for each CDN prefix. 
	 @return ApiReadCdnPrefixRequest
	*/
	ReadCdnPrefix(ctx _context.Context, contentProviderId int32, cdnPrefixId int32) ApiReadCdnPrefixRequest

	// ReadCdnPrefixExecute executes the request
	//  @return CdnPrefixReadDetailed
	ReadCdnPrefixExecute(r ApiReadCdnPrefixRequest) (CdnPrefixReadDetailed, *_nethttp.Response, error)

	/*
	ReadCdnPrefixRules rules

	Get a rule tree: This operation displays the default rule
behaviors for a CDN prefix.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param cdnPrefixId Unique identifier for each CDN prefix. 
	 @return ApiReadCdnPrefixRulesRequest
	*/
	ReadCdnPrefixRules(ctx _context.Context, contentProviderId int32, cdnPrefixId int32) ApiReadCdnPrefixRulesRequest

	// ReadCdnPrefixRulesExecute executes the request
	//  @return CdnPrefixRules
	ReadCdnPrefixRulesExecute(r ApiReadCdnPrefixRulesRequest) (CdnPrefixRules, *_nethttp.Response, error)

	/*
	ReadContentProvider content provider

	Get a Content Provider: This operation gets the specified Content Provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each Content Provider. 
	 @return ApiReadContentProviderRequest
	*/
	ReadContentProvider(ctx _context.Context, contentProviderId int32) ApiReadContentProviderRequest

	// ReadContentProviderExecute executes the request
	//  @return ContentProviderReadDetailed
	ReadContentProviderExecute(r ApiReadContentProviderRequest) (ContentProviderReadDetailed, *_nethttp.Response, error)

	/*
	ReadOrigin origin

	Get an origin: This operation displays a list of origin
servers associated with a specified content provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param originId Unique identifier for each origin. 
	 @return ApiReadOriginRequest
	*/
	ReadOrigin(ctx _context.Context, contentProviderId int32, originId int32) ApiReadOriginRequest

	// ReadOriginExecute executes the request
	//  @return OriginReadDetailed
	ReadOriginExecute(r ApiReadOriginRequest) (OriginReadDetailed, *_nethttp.Response, error)

	/*
	ReadSharedSecretSet shared secret set

	Get a shared secret set: This operation gets the details about
a shared secret set for a specified content provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param sharedSecretSetId Unique identifier for each shared secret set. 
	 @return ApiReadSharedSecretSetRequest
	*/
	ReadSharedSecretSet(ctx _context.Context, contentProviderId int32, sharedSecretSetId int32) ApiReadSharedSecretSetRequest

	// ReadSharedSecretSetExecute executes the request
	//  @return SharedSecretSetReadDetailed
	ReadSharedSecretSetExecute(r ApiReadSharedSecretSetRequest) (SharedSecretSetReadDetailed, *_nethttp.Response, error)

	/*
	ReadSharedSecretSetSecrets secrets

	Get secrets: This operations gets the details of a shared
secret set for a specified content provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param sharedSecretSetId Unique identifier for each shared secret set. 
	 @return ApiReadSharedSecretSetSecretsRequest
	*/
	ReadSharedSecretSetSecrets(ctx _context.Context, contentProviderId int32, sharedSecretSetId int32) ApiReadSharedSecretSetSecretsRequest

	// ReadSharedSecretSetSecretsExecute executes the request
	//  @return SharedSecretSetSecrets
	ReadSharedSecretSetSecretsExecute(r ApiReadSharedSecretSetSecretsRequest) (SharedSecretSetSecrets, *_nethttp.Response, error)

	/*
	ReadTlsDeliveryProfile tls delivery profile

	Get a TLS delivery profile: This operation gets the specified
TLS delivery profile for the specified content provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param tlsDeliveryProfileId Unique identifier for each TLS delivery profile. 
	 @return ApiReadTlsDeliveryProfileRequest
	*/
	ReadTlsDeliveryProfile(ctx _context.Context, contentProviderId int32, tlsDeliveryProfileId int32) ApiReadTlsDeliveryProfileRequest

	// ReadTlsDeliveryProfileExecute executes the request
	//  @return TlsDeliveryProfileReadDetailed
	ReadTlsDeliveryProfileExecute(r ApiReadTlsDeliveryProfileRequest) (TlsDeliveryProfileReadDetailed, *_nethttp.Response, error)

	/*
	ReadTlsIngestProfile tls ingest profile

	Get a TLS ingest profile: This operation gets details about a
specified TLS ingest profile.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param tlsIngestProfileId Unique identifier for each TLS ingest profile. 
	 @return ApiReadTlsIngestProfileRequest
	*/
	ReadTlsIngestProfile(ctx _context.Context, contentProviderId int32, tlsIngestProfileId int32) ApiReadTlsIngestProfileRequest

	// ReadTlsIngestProfileExecute executes the request
	//  @return TlsIngestProfileReadDetailed
	ReadTlsIngestProfileExecute(r ApiReadTlsIngestProfileRequest) (TlsIngestProfileReadDetailed, *_nethttp.Response, error)

	/*
	UpdateCdnPrefix cdn prefix

	Update a CDN Prefix: This operation modifies an existing CDN prefix.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param cdnPrefixId Unique identifier for each CDN prefix. 
	 @return ApiUpdateCdnPrefixRequest
	*/
	UpdateCdnPrefix(ctx _context.Context, contentProviderId int32, cdnPrefixId int32) ApiUpdateCdnPrefixRequest

	// UpdateCdnPrefixExecute executes the request
	//  @return CdnPrefixReadDetailed
	UpdateCdnPrefixExecute(r ApiUpdateCdnPrefixRequest) (CdnPrefixReadDetailed, *_nethttp.Response, error)

	/*
	UpdateCdnPrefixRules rules

	Update a rule tree: This operation updates the rule behaviors for a CDN prefix.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param cdnPrefixId Unique identifier for each CDN prefix. 
	 @return ApiUpdateCdnPrefixRulesRequest
	*/
	UpdateCdnPrefixRules(ctx _context.Context, contentProviderId int32, cdnPrefixId int32) ApiUpdateCdnPrefixRulesRequest

	// UpdateCdnPrefixRulesExecute executes the request
	//  @return CdnPrefixRules
	UpdateCdnPrefixRulesExecute(r ApiUpdateCdnPrefixRulesRequest) (CdnPrefixRules, *_nethttp.Response, error)

	/*
	UpdateOrigin origin

	Update an origin: This operation modifies the origin servers
associated with a specified content provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param originId Unique identifier for each origin. 
	 @return ApiUpdateOriginRequest
	*/
	UpdateOrigin(ctx _context.Context, contentProviderId int32, originId int32) ApiUpdateOriginRequest

	// UpdateOriginExecute executes the request
	//  @return OriginReadDetailed
	UpdateOriginExecute(r ApiUpdateOriginRequest) (OriginReadDetailed, *_nethttp.Response, error)

	/*
	UpdateSharedSecretSetSecrets secrets

	Update secrets: This operations updates the details of a
Shared Secret Set for a specified Content Provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param sharedSecretSetId Unique identifier for each shared secret set. 
	 @return ApiUpdateSharedSecretSetSecretsRequest
	*/
	UpdateSharedSecretSetSecrets(ctx _context.Context, contentProviderId int32, sharedSecretSetId int32) ApiUpdateSharedSecretSetSecretsRequest

	// UpdateSharedSecretSetSecretsExecute executes the request
	//  @return SharedSecretSetSecrets
	UpdateSharedSecretSetSecretsExecute(r ApiUpdateSharedSecretSetSecretsRequest) (SharedSecretSetSecrets, *_nethttp.Response, error)

	/*
	UpdateTlsDeliveryProfile tls delivery profile

	Update a TLS delivery profile: After you create a content
provider TLS delivery profile, you can use this operation to
modify the profile parameters for the specified content
provider.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param tlsDeliveryProfileId Unique identifier for each TLS delivery profile. 
	 @return ApiUpdateTlsDeliveryProfileRequest
	*/
	UpdateTlsDeliveryProfile(ctx _context.Context, contentProviderId int32, tlsDeliveryProfileId int32) ApiUpdateTlsDeliveryProfileRequest

	// UpdateTlsDeliveryProfileExecute executes the request
	//  @return TlsDeliveryProfileReadDetailed
	UpdateTlsDeliveryProfileExecute(r ApiUpdateTlsDeliveryProfileRequest) (TlsDeliveryProfileReadDetailed, *_nethttp.Response, error)

	/*
	UpdateTlsIngestProfile tls ingest profile

	Update a TLS ingest profile: After you create a TLS ingest
profile, you can modify its attributes using this operation.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param contentProviderId Unique identifier for each content provider. 
	 @param tlsIngestProfileId Unique identifier for each TLS ingest profile. 
	 @return ApiUpdateTlsIngestProfileRequest
	*/
	UpdateTlsIngestProfile(ctx _context.Context, contentProviderId int32, tlsIngestProfileId int32) ApiUpdateTlsIngestProfileRequest

	// UpdateTlsIngestProfileExecute executes the request
	//  @return TlsIngestProfileReadDetailed
	UpdateTlsIngestProfileExecute(r ApiUpdateTlsIngestProfileRequest) (TlsIngestProfileReadDetailed, *_nethttp.Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiCreateCdnPrefixRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	cdnPrefixCreate *CdnPrefixCreate
}

func (r ApiCreateCdnPrefixRequest) CdnPrefixCreate(cdnPrefixCreate CdnPrefixCreate) ApiCreateCdnPrefixRequest {
	r.cdnPrefixCreate = &cdnPrefixCreate
	return r
}

func (r ApiCreateCdnPrefixRequest) Execute() (CdnPrefixReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.CreateCdnPrefixExecute(r)
}

/*
CreateCdnPrefix cdn prefixes

Create a New CDN prefix: This operation creates a new CDN
prefix. A CDN prefix is a defined hostname which is referenced
by an end user's request for content. This is accomplished using
a DNS lookup directed to a node running the request router service.
The request router then determines the HPC node best able to serve
that particular end user's request.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @return ApiCreateCdnPrefixRequest
*/
func (a *DefaultApiService) CreateCdnPrefix(ctx _context.Context, contentProviderId int32) ApiCreateCdnPrefixRequest {
	return ApiCreateCdnPrefixRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
	}
}

// Execute executes the request
//  @return CdnPrefixReadDetailed
func (a *DefaultApiService) CreateCdnPrefixExecute(r ApiCreateCdnPrefixRequest) (CdnPrefixReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CdnPrefixReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateCdnPrefix")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/cdn-prefixes"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.cdnPrefixCreate == nil {
		return localVarReturnValue, nil, reportError("cdnPrefixCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cdnPrefixCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOriginRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	originCreate *OriginCreate
}

func (r ApiCreateOriginRequest) OriginCreate(originCreate OriginCreate) ApiCreateOriginRequest {
	r.originCreate = &originCreate
	return r
}

func (r ApiCreateOriginRequest) Execute() (OriginReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.CreateOriginExecute(r)
}

/*
CreateOrigin origins

Create a new origin: This operation allows a service provider to
register a new URL for each origin server that a content
provider wants to add to the CDN.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @return ApiCreateOriginRequest
*/
func (a *DefaultApiService) CreateOrigin(ctx _context.Context, contentProviderId int32) ApiCreateOriginRequest {
	return ApiCreateOriginRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
	}
}

// Execute executes the request
//  @return OriginReadDetailed
func (a *DefaultApiService) CreateOriginExecute(r ApiCreateOriginRequest) (OriginReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OriginReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateOrigin")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/origins"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.originCreate == nil {
		return localVarReturnValue, nil, reportError("originCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.originCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSharedSecretSetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	sharedSecretSetCreate *SharedSecretSetCreate
}

func (r ApiCreateSharedSecretSetRequest) SharedSecretSetCreate(sharedSecretSetCreate SharedSecretSetCreate) ApiCreateSharedSecretSetRequest {
	r.sharedSecretSetCreate = &sharedSecretSetCreate
	return r
}

func (r ApiCreateSharedSecretSetRequest) Execute() (SharedSecretSetReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.CreateSharedSecretSetExecute(r)
}

/*
CreateSharedSecretSet shared secret sets

Create a new shared secret set: This operation creates a new
shared secret set for the specified content provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @return ApiCreateSharedSecretSetRequest
*/
func (a *DefaultApiService) CreateSharedSecretSet(ctx _context.Context, contentProviderId int32) ApiCreateSharedSecretSetRequest {
	return ApiCreateSharedSecretSetRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
	}
}

// Execute executes the request
//  @return SharedSecretSetReadDetailed
func (a *DefaultApiService) CreateSharedSecretSetExecute(r ApiCreateSharedSecretSetRequest) (SharedSecretSetReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SharedSecretSetReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSharedSecretSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/shared-secret-sets"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.sharedSecretSetCreate == nil {
		return localVarReturnValue, nil, reportError("sharedSecretSetCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharedSecretSetCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTlsDeliveryProfileRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	tlsDeliveryProfileCreate *TlsDeliveryProfileCreate
}

func (r ApiCreateTlsDeliveryProfileRequest) TlsDeliveryProfileCreate(tlsDeliveryProfileCreate TlsDeliveryProfileCreate) ApiCreateTlsDeliveryProfileRequest {
	r.tlsDeliveryProfileCreate = &tlsDeliveryProfileCreate
	return r
}

func (r ApiCreateTlsDeliveryProfileRequest) Execute() (TlsDeliveryProfileReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.CreateTlsDeliveryProfileExecute(r)
}

/*
CreateTlsDeliveryProfile tls delivery profiles

Create a new TLS delivery profile: This operation creates a new
content provider TLS delivery profile. The content provider TLS
delivery profile specifies the security settings used for TLS
connections when a content provider wants content delivered over
HTTPS. This type of profile is created by the content provider,
and its available for use by CDN prefixes owned by that content
provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @return ApiCreateTlsDeliveryProfileRequest
*/
func (a *DefaultApiService) CreateTlsDeliveryProfile(ctx _context.Context, contentProviderId int32) ApiCreateTlsDeliveryProfileRequest {
	return ApiCreateTlsDeliveryProfileRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
	}
}

// Execute executes the request
//  @return TlsDeliveryProfileReadDetailed
func (a *DefaultApiService) CreateTlsDeliveryProfileExecute(r ApiCreateTlsDeliveryProfileRequest) (TlsDeliveryProfileReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TlsDeliveryProfileReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateTlsDeliveryProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/tls-delivery-profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tlsDeliveryProfileCreate == nil {
		return localVarReturnValue, nil, reportError("tlsDeliveryProfileCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tlsDeliveryProfileCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateTlsIngestProfilesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	tlsIngestProfileCreate *TlsIngestProfileCreate
}

func (r ApiCreateTlsIngestProfilesRequest) TlsIngestProfileCreate(tlsIngestProfileCreate TlsIngestProfileCreate) ApiCreateTlsIngestProfilesRequest {
	r.tlsIngestProfileCreate = &tlsIngestProfileCreate
	return r
}

func (r ApiCreateTlsIngestProfilesRequest) Execute() (TlsIngestProfileReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.CreateTlsIngestProfilesExecute(r)
}

/*
CreateTlsIngestProfiles tls ingest profiles

Create a new TLS ingest profile: This operation creates a TLS
ingest profile. To configure the ingest of content from an
origin over HTTPS, a content provider must first create a TLS
ingest profile and bind the profile to the origin. The
HyperCache uses the TLS parameters specified in the TLS ingest
profile to ingest content from the origin. A TLS ingest profile
can be bound to one or more origins, and can only be deleted if
it is not bound to an origin.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @return ApiCreateTlsIngestProfilesRequest
*/
func (a *DefaultApiService) CreateTlsIngestProfiles(ctx _context.Context, contentProviderId int32) ApiCreateTlsIngestProfilesRequest {
	return ApiCreateTlsIngestProfilesRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
	}
}

// Execute executes the request
//  @return TlsIngestProfileReadDetailed
func (a *DefaultApiService) CreateTlsIngestProfilesExecute(r ApiCreateTlsIngestProfilesRequest) (TlsIngestProfileReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TlsIngestProfileReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateTlsIngestProfiles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/tls-ingest-profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tlsIngestProfileCreate == nil {
		return localVarReturnValue, nil, reportError("tlsIngestProfileCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tlsIngestProfileCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCdnPrefixRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	cdnPrefixId int32
}


func (r ApiDeleteCdnPrefixRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteCdnPrefixExecute(r)
}

/*
DeleteCdnPrefix cdn prefix

Delete a CDN prefix: This operation deletes a CDN prefix.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param cdnPrefixId Unique identifier for each CDN prefix. 
 @return ApiDeleteCdnPrefixRequest
*/
func (a *DefaultApiService) DeleteCdnPrefix(ctx _context.Context, contentProviderId int32, cdnPrefixId int32) ApiDeleteCdnPrefixRequest {
	return ApiDeleteCdnPrefixRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		cdnPrefixId: cdnPrefixId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteCdnPrefixExecute(r ApiDeleteCdnPrefixRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteCdnPrefix")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/cdn-prefixes/{cdnPrefixId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cdnPrefixId"+"}", _neturl.PathEscape(parameterToString(r.cdnPrefixId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteOriginRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	originId int32
}


func (r ApiDeleteOriginRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteOriginExecute(r)
}

/*
DeleteOrigin origin

Delete an origin: This operation removes the association of an
origin server from the specified content provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param originId Unique identifier for each origin. 
 @return ApiDeleteOriginRequest
*/
func (a *DefaultApiService) DeleteOrigin(ctx _context.Context, contentProviderId int32, originId int32) ApiDeleteOriginRequest {
	return ApiDeleteOriginRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		originId: originId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteOriginExecute(r ApiDeleteOriginRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteOrigin")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/origins/{originId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"originId"+"}", _neturl.PathEscape(parameterToString(r.originId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSharedSecretSetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	sharedSecretSetId int32
}


func (r ApiDeleteSharedSecretSetRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteSharedSecretSetExecute(r)
}

/*
DeleteSharedSecretSet shared secret set

Delete a shared secret: This operation deletes a shared secret
set for a specified content provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param sharedSecretSetId Unique identifier for each shared secret set. 
 @return ApiDeleteSharedSecretSetRequest
*/
func (a *DefaultApiService) DeleteSharedSecretSet(ctx _context.Context, contentProviderId int32, sharedSecretSetId int32) ApiDeleteSharedSecretSetRequest {
	return ApiDeleteSharedSecretSetRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		sharedSecretSetId: sharedSecretSetId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSharedSecretSetExecute(r ApiDeleteSharedSecretSetRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSharedSecretSet")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/shared-secret-sets/{sharedSecretSetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedSecretSetId"+"}", _neturl.PathEscape(parameterToString(r.sharedSecretSetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTlsDeliveryProfileRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	tlsDeliveryProfileId int32
}


func (r ApiDeleteTlsDeliveryProfileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteTlsDeliveryProfileExecute(r)
}

/*
DeleteTlsDeliveryProfile tls delivery profile

Delete a TLS delivery profile: This operation deletes a TLS
delivery profile for the specified content provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param tlsDeliveryProfileId Unique identifier for each TLS delivery profile. 
 @return ApiDeleteTlsDeliveryProfileRequest
*/
func (a *DefaultApiService) DeleteTlsDeliveryProfile(ctx _context.Context, contentProviderId int32, tlsDeliveryProfileId int32) ApiDeleteTlsDeliveryProfileRequest {
	return ApiDeleteTlsDeliveryProfileRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		tlsDeliveryProfileId: tlsDeliveryProfileId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteTlsDeliveryProfileExecute(r ApiDeleteTlsDeliveryProfileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteTlsDeliveryProfile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/tls-delivery-profiles/{tlsDeliveryProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tlsDeliveryProfileId"+"}", _neturl.PathEscape(parameterToString(r.tlsDeliveryProfileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTlsIngestProfileRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	tlsIngestProfileId int32
}


func (r ApiDeleteTlsIngestProfileRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteTlsIngestProfileExecute(r)
}

/*
DeleteTlsIngestProfile tls ingest profile

Delete a TLS ingest profile: This operation deletes a TLS
ingest profile for the specified content provider. A TLS
ingest profile can be bound to one or more origins, and can
only be deleted if it is not bound to an origin.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param tlsIngestProfileId Unique identifier for each TLS ingest profile. 
 @return ApiDeleteTlsIngestProfileRequest
*/
func (a *DefaultApiService) DeleteTlsIngestProfile(ctx _context.Context, contentProviderId int32, tlsIngestProfileId int32) ApiDeleteTlsIngestProfileRequest {
	return ApiDeleteTlsIngestProfileRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		tlsIngestProfileId: tlsIngestProfileId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteTlsIngestProfileExecute(r ApiDeleteTlsIngestProfileRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteTlsIngestProfile")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/tls-ingest-profiles/{tlsIngestProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tlsIngestProfileId"+"}", _neturl.PathEscape(parameterToString(r.tlsIngestProfileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListCdnPrefixesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// Results display either &#x60;summary&#x60; or &#x60;detailed&#x60; objects. 
func (r ApiListCdnPrefixesRequest) View(view string) ApiListCdnPrefixesRequest {
	r.view = &view
	return r
}
// Specifies a query to filter down the set of results. The accompanying example specifies more than one query, where &#x60;;&#x60; and &#x60;,&#x60; delimiters clarify AND and OR logic. (Optional parentheses clarify logical groupings.) The &#x60;&#x3D;&#x3D;&#x60; and &#x60;!&#x3D;&#x60; operators test equivalency. The &#x60;&#x3D;lt&#x3D;&#x60;, &#x60;&#x3D;le&#x3D;&#x60;, &#x60;&#x3D;gt&#x3D;&#x60;, and &#x60;&#x3D;ge&#x3D;&#x60; operators compare numbers. The &#x60;&#x3D;contains&#x3D;&#x60; and &#x60;&#x3D;excludes&#x3D;&#x60; operators match elements within an array. 
func (r ApiListCdnPrefixesRequest) Filter(filter string) ApiListCdnPrefixesRequest {
	r.filter = &filter
	return r
}
// Specifies an object field name to sort results on. Provide a comma-separated list of field names for additional sort criteria. Prefix field names with a dash for descending sort order. For example, &#x60;name,-tlsIngestProfileId&#x60; sorts primarily by name, then IDs in descending order. 
func (r ApiListCdnPrefixesRequest) SortBy(sortBy string) ApiListCdnPrefixesRequest {
	r.sortBy = &sortBy
	return r
}
// Specifies an offset within the full set of results, with page numbers starting at 1.  Use this in conjunction with &#x60;pageSize&#x60;. 
func (r ApiListCdnPrefixesRequest) PageNumber(pageNumber int32) ApiListCdnPrefixesRequest {
	r.pageNumber = &pageNumber
	return r
}
// Specifies the number of results on each page.  Use this in conjunction with &#x60;pageNumber&#x60;. 
func (r ApiListCdnPrefixesRequest) PageSize(pageSize int32) ApiListCdnPrefixesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListCdnPrefixesRequest) Execute() (CdnPrefixCollection, *_nethttp.Response, error) {
	return r.ApiService.ListCdnPrefixesExecute(r)
}

/*
ListCdnPrefixes cdn prefixes

List CDN prefixes: This operation provides a list of the CDN
prefixes owned by the content provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @return ApiListCdnPrefixesRequest
*/
func (a *DefaultApiService) ListCdnPrefixes(ctx _context.Context, contentProviderId int32) ApiListCdnPrefixesRequest {
	return ApiListCdnPrefixesRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
	}
}

// Execute executes the request
//  @return CdnPrefixCollection
func (a *DefaultApiService) ListCdnPrefixesExecute(r ApiListCdnPrefixesRequest) (CdnPrefixCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CdnPrefixCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListCdnPrefixes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/cdn-prefixes"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListContentProvidersRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// Results display either &#x60;summary&#x60; or &#x60;detailed&#x60; objects. 
func (r ApiListContentProvidersRequest) View(view string) ApiListContentProvidersRequest {
	r.view = &view
	return r
}
// Specifies a query to filter down the set of results. The accompanying example specifies more than one query, where &#x60;;&#x60; and &#x60;,&#x60; delimiters clarify AND and OR logic. (Optional parentheses clarify logical groupings.) The &#x60;&#x3D;&#x3D;&#x60; and &#x60;!&#x3D;&#x60; operators test equivalency. The &#x60;&#x3D;lt&#x3D;&#x60;, &#x60;&#x3D;le&#x3D;&#x60;, &#x60;&#x3D;gt&#x3D;&#x60;, and &#x60;&#x3D;ge&#x3D;&#x60; operators compare numbers. The &#x60;&#x3D;contains&#x3D;&#x60; and &#x60;&#x3D;excludes&#x3D;&#x60; operators match elements within an array. 
func (r ApiListContentProvidersRequest) Filter(filter string) ApiListContentProvidersRequest {
	r.filter = &filter
	return r
}
// Specifies an object field name to sort results on. Provide a comma-separated list of field names for additional sort criteria. Prefix field names with a dash for descending sort order. For example, &#x60;name,-tlsIngestProfileId&#x60; sorts primarily by name, then IDs in descending order. 
func (r ApiListContentProvidersRequest) SortBy(sortBy string) ApiListContentProvidersRequest {
	r.sortBy = &sortBy
	return r
}
// Specifies an offset within the full set of results, with page numbers starting at 1.  Use this in conjunction with &#x60;pageSize&#x60;. 
func (r ApiListContentProvidersRequest) PageNumber(pageNumber int32) ApiListContentProvidersRequest {
	r.pageNumber = &pageNumber
	return r
}
// Specifies the number of results on each page.  Use this in conjunction with &#x60;pageNumber&#x60;. 
func (r ApiListContentProvidersRequest) PageSize(pageSize int32) ApiListContentProvidersRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListContentProvidersRequest) Execute() (ContentProviderCollection, *_nethttp.Response, error) {
	return r.ApiService.ListContentProvidersExecute(r)
}

/*
ListContentProviders content providers

List Content Providers: This operation provides a list of Content Providers
accessible to the principal. For Operators, all Content Providers in the system
are returned. For Content Provider users, only the Content Providers that are
associated with that user are returned. For Service Provider users, all Content
Providers associated with that user and with that Service Provider are returned.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListContentProvidersRequest
*/
func (a *DefaultApiService) ListContentProviders(ctx _context.Context) ApiListContentProvidersRequest {
	return ApiListContentProvidersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ContentProviderCollection
func (a *DefaultApiService) ListContentProvidersExecute(r ApiListContentProvidersRequest) (ContentProviderCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ContentProviderCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListContentProviders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOriginsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// Results display either &#x60;summary&#x60; or &#x60;detailed&#x60; objects. 
func (r ApiListOriginsRequest) View(view string) ApiListOriginsRequest {
	r.view = &view
	return r
}
// Specifies a query to filter down the set of results. The accompanying example specifies more than one query, where &#x60;;&#x60; and &#x60;,&#x60; delimiters clarify AND and OR logic. (Optional parentheses clarify logical groupings.) The &#x60;&#x3D;&#x3D;&#x60; and &#x60;!&#x3D;&#x60; operators test equivalency. The &#x60;&#x3D;lt&#x3D;&#x60;, &#x60;&#x3D;le&#x3D;&#x60;, &#x60;&#x3D;gt&#x3D;&#x60;, and &#x60;&#x3D;ge&#x3D;&#x60; operators compare numbers. The &#x60;&#x3D;contains&#x3D;&#x60; and &#x60;&#x3D;excludes&#x3D;&#x60; operators match elements within an array. 
func (r ApiListOriginsRequest) Filter(filter string) ApiListOriginsRequest {
	r.filter = &filter
	return r
}
// Specifies an object field name to sort results on. Provide a comma-separated list of field names for additional sort criteria. Prefix field names with a dash for descending sort order. For example, &#x60;name,-tlsIngestProfileId&#x60; sorts primarily by name, then IDs in descending order. 
func (r ApiListOriginsRequest) SortBy(sortBy string) ApiListOriginsRequest {
	r.sortBy = &sortBy
	return r
}
// Specifies an offset within the full set of results, with page numbers starting at 1.  Use this in conjunction with &#x60;pageSize&#x60;. 
func (r ApiListOriginsRequest) PageNumber(pageNumber int32) ApiListOriginsRequest {
	r.pageNumber = &pageNumber
	return r
}
// Specifies the number of results on each page.  Use this in conjunction with &#x60;pageNumber&#x60;. 
func (r ApiListOriginsRequest) PageSize(pageSize int32) ApiListOriginsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListOriginsRequest) Execute() (OriginCollection, *_nethttp.Response, error) {
	return r.ApiService.ListOriginsExecute(r)
}

/*
ListOrigins origins

List origins: This operation displays the origins owned by the
Content Provider specified by `contentProviderId`.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @return ApiListOriginsRequest
*/
func (a *DefaultApiService) ListOrigins(ctx _context.Context, contentProviderId int32) ApiListOriginsRequest {
	return ApiListOriginsRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
	}
}

// Execute executes the request
//  @return OriginCollection
func (a *DefaultApiService) ListOriginsExecute(r ApiListOriginsRequest) (OriginCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OriginCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListOrigins")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/origins"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSharedSecretSetsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// Results display either &#x60;summary&#x60; or &#x60;detailed&#x60; objects. 
func (r ApiListSharedSecretSetsRequest) View(view string) ApiListSharedSecretSetsRequest {
	r.view = &view
	return r
}
// Specifies a query to filter down the set of results. The accompanying example specifies more than one query, where &#x60;;&#x60; and &#x60;,&#x60; delimiters clarify AND and OR logic. (Optional parentheses clarify logical groupings.) The &#x60;&#x3D;&#x3D;&#x60; and &#x60;!&#x3D;&#x60; operators test equivalency. The &#x60;&#x3D;lt&#x3D;&#x60;, &#x60;&#x3D;le&#x3D;&#x60;, &#x60;&#x3D;gt&#x3D;&#x60;, and &#x60;&#x3D;ge&#x3D;&#x60; operators compare numbers. The &#x60;&#x3D;contains&#x3D;&#x60; and &#x60;&#x3D;excludes&#x3D;&#x60; operators match elements within an array. 
func (r ApiListSharedSecretSetsRequest) Filter(filter string) ApiListSharedSecretSetsRequest {
	r.filter = &filter
	return r
}
// Specifies an object field name to sort results on. Provide a comma-separated list of field names for additional sort criteria. Prefix field names with a dash for descending sort order. For example, &#x60;name,-tlsIngestProfileId&#x60; sorts primarily by name, then IDs in descending order. 
func (r ApiListSharedSecretSetsRequest) SortBy(sortBy string) ApiListSharedSecretSetsRequest {
	r.sortBy = &sortBy
	return r
}
// Specifies an offset within the full set of results, with page numbers starting at 1.  Use this in conjunction with &#x60;pageSize&#x60;. 
func (r ApiListSharedSecretSetsRequest) PageNumber(pageNumber int32) ApiListSharedSecretSetsRequest {
	r.pageNumber = &pageNumber
	return r
}
// Specifies the number of results on each page.  Use this in conjunction with &#x60;pageNumber&#x60;. 
func (r ApiListSharedSecretSetsRequest) PageSize(pageSize int32) ApiListSharedSecretSetsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListSharedSecretSetsRequest) Execute() (SharedSecretSetCollection, *_nethttp.Response, error) {
	return r.ApiService.ListSharedSecretSetsExecute(r)
}

/*
ListSharedSecretSets shared secret sets

List shared secret sets: This operation lists all shared secrets
sets for a specified content provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @return ApiListSharedSecretSetsRequest
*/
func (a *DefaultApiService) ListSharedSecretSets(ctx _context.Context, contentProviderId int32) ApiListSharedSecretSetsRequest {
	return ApiListSharedSecretSetsRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
	}
}

// Execute executes the request
//  @return SharedSecretSetCollection
func (a *DefaultApiService) ListSharedSecretSetsExecute(r ApiListSharedSecretSetsRequest) (SharedSecretSetCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SharedSecretSetCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSharedSecretSets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/shared-secret-sets"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTlsDeliveryProfileCdnPrefixesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	tlsDeliveryProfileId int32
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// Results display either &#x60;summary&#x60; or &#x60;detailed&#x60; objects. 
func (r ApiListTlsDeliveryProfileCdnPrefixesRequest) View(view string) ApiListTlsDeliveryProfileCdnPrefixesRequest {
	r.view = &view
	return r
}
// Specifies a query to filter down the set of results. The accompanying example specifies more than one query, where &#x60;;&#x60; and &#x60;,&#x60; delimiters clarify AND and OR logic. (Optional parentheses clarify logical groupings.) The &#x60;&#x3D;&#x3D;&#x60; and &#x60;!&#x3D;&#x60; operators test equivalency. The &#x60;&#x3D;lt&#x3D;&#x60;, &#x60;&#x3D;le&#x3D;&#x60;, &#x60;&#x3D;gt&#x3D;&#x60;, and &#x60;&#x3D;ge&#x3D;&#x60; operators compare numbers. The &#x60;&#x3D;contains&#x3D;&#x60; and &#x60;&#x3D;excludes&#x3D;&#x60; operators match elements within an array. 
func (r ApiListTlsDeliveryProfileCdnPrefixesRequest) Filter(filter string) ApiListTlsDeliveryProfileCdnPrefixesRequest {
	r.filter = &filter
	return r
}
// Specifies an object field name to sort results on. Provide a comma-separated list of field names for additional sort criteria. Prefix field names with a dash for descending sort order. For example, &#x60;name,-tlsIngestProfileId&#x60; sorts primarily by name, then IDs in descending order. 
func (r ApiListTlsDeliveryProfileCdnPrefixesRequest) SortBy(sortBy string) ApiListTlsDeliveryProfileCdnPrefixesRequest {
	r.sortBy = &sortBy
	return r
}
// Specifies an offset within the full set of results, with page numbers starting at 1.  Use this in conjunction with &#x60;pageSize&#x60;. 
func (r ApiListTlsDeliveryProfileCdnPrefixesRequest) PageNumber(pageNumber int32) ApiListTlsDeliveryProfileCdnPrefixesRequest {
	r.pageNumber = &pageNumber
	return r
}
// Specifies the number of results on each page.  Use this in conjunction with &#x60;pageNumber&#x60;. 
func (r ApiListTlsDeliveryProfileCdnPrefixesRequest) PageSize(pageSize int32) ApiListTlsDeliveryProfileCdnPrefixesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListTlsDeliveryProfileCdnPrefixesRequest) Execute() (CdnPrefixCollection, *_nethttp.Response, error) {
	return r.ApiService.ListTlsDeliveryProfileCdnPrefixesExecute(r)
}

/*
ListTlsDeliveryProfileCdnPrefixes cdn prefixes per tls

List CDN prefixes for a TLS delivery profile: This operation
displays the list of CDN prefixes for the specified TLS
delivery profile.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param tlsDeliveryProfileId Unique identifier for each TLS delivery profile. 
 @return ApiListTlsDeliveryProfileCdnPrefixesRequest
*/
func (a *DefaultApiService) ListTlsDeliveryProfileCdnPrefixes(ctx _context.Context, contentProviderId int32, tlsDeliveryProfileId int32) ApiListTlsDeliveryProfileCdnPrefixesRequest {
	return ApiListTlsDeliveryProfileCdnPrefixesRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		tlsDeliveryProfileId: tlsDeliveryProfileId,
	}
}

// Execute executes the request
//  @return CdnPrefixCollection
func (a *DefaultApiService) ListTlsDeliveryProfileCdnPrefixesExecute(r ApiListTlsDeliveryProfileCdnPrefixesRequest) (CdnPrefixCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CdnPrefixCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListTlsDeliveryProfileCdnPrefixes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/tls-delivery-profiles/{tlsDeliveryProfileId}/cdn-prefixes"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tlsDeliveryProfileId"+"}", _neturl.PathEscape(parameterToString(r.tlsDeliveryProfileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTlsDeliveryProfilesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// Results display either &#x60;summary&#x60; or &#x60;detailed&#x60; objects. 
func (r ApiListTlsDeliveryProfilesRequest) View(view string) ApiListTlsDeliveryProfilesRequest {
	r.view = &view
	return r
}
// Specifies a query to filter down the set of results. The accompanying example specifies more than one query, where &#x60;;&#x60; and &#x60;,&#x60; delimiters clarify AND and OR logic. (Optional parentheses clarify logical groupings.) The &#x60;&#x3D;&#x3D;&#x60; and &#x60;!&#x3D;&#x60; operators test equivalency. The &#x60;&#x3D;lt&#x3D;&#x60;, &#x60;&#x3D;le&#x3D;&#x60;, &#x60;&#x3D;gt&#x3D;&#x60;, and &#x60;&#x3D;ge&#x3D;&#x60; operators compare numbers. The &#x60;&#x3D;contains&#x3D;&#x60; and &#x60;&#x3D;excludes&#x3D;&#x60; operators match elements within an array. 
func (r ApiListTlsDeliveryProfilesRequest) Filter(filter string) ApiListTlsDeliveryProfilesRequest {
	r.filter = &filter
	return r
}
// Specifies an object field name to sort results on. Provide a comma-separated list of field names for additional sort criteria. Prefix field names with a dash for descending sort order. For example, &#x60;name,-tlsIngestProfileId&#x60; sorts primarily by name, then IDs in descending order. 
func (r ApiListTlsDeliveryProfilesRequest) SortBy(sortBy string) ApiListTlsDeliveryProfilesRequest {
	r.sortBy = &sortBy
	return r
}
// Specifies an offset within the full set of results, with page numbers starting at 1.  Use this in conjunction with &#x60;pageSize&#x60;. 
func (r ApiListTlsDeliveryProfilesRequest) PageNumber(pageNumber int32) ApiListTlsDeliveryProfilesRequest {
	r.pageNumber = &pageNumber
	return r
}
// Specifies the number of results on each page.  Use this in conjunction with &#x60;pageNumber&#x60;. 
func (r ApiListTlsDeliveryProfilesRequest) PageSize(pageSize int32) ApiListTlsDeliveryProfilesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListTlsDeliveryProfilesRequest) Execute() (TlsDeliveryProfileCollection, *_nethttp.Response, error) {
	return r.ApiService.ListTlsDeliveryProfilesExecute(r)
}

/*
ListTlsDeliveryProfiles tls delivery profiles

List TLS delivery profiles: This operation lists the TLS
delivery profiles owned by the specified content provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @return ApiListTlsDeliveryProfilesRequest
*/
func (a *DefaultApiService) ListTlsDeliveryProfiles(ctx _context.Context, contentProviderId int32) ApiListTlsDeliveryProfilesRequest {
	return ApiListTlsDeliveryProfilesRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
	}
}

// Execute executes the request
//  @return TlsDeliveryProfileCollection
func (a *DefaultApiService) ListTlsDeliveryProfilesExecute(r ApiListTlsDeliveryProfilesRequest) (TlsDeliveryProfileCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TlsDeliveryProfileCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListTlsDeliveryProfiles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/tls-delivery-profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTlsIngestProfileOriginsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	tlsIngestProfileId int32
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// Results display either &#x60;summary&#x60; or &#x60;detailed&#x60; objects. 
func (r ApiListTlsIngestProfileOriginsRequest) View(view string) ApiListTlsIngestProfileOriginsRequest {
	r.view = &view
	return r
}
// Specifies a query to filter down the set of results. The accompanying example specifies more than one query, where &#x60;;&#x60; and &#x60;,&#x60; delimiters clarify AND and OR logic. (Optional parentheses clarify logical groupings.) The &#x60;&#x3D;&#x3D;&#x60; and &#x60;!&#x3D;&#x60; operators test equivalency. The &#x60;&#x3D;lt&#x3D;&#x60;, &#x60;&#x3D;le&#x3D;&#x60;, &#x60;&#x3D;gt&#x3D;&#x60;, and &#x60;&#x3D;ge&#x3D;&#x60; operators compare numbers. The &#x60;&#x3D;contains&#x3D;&#x60; and &#x60;&#x3D;excludes&#x3D;&#x60; operators match elements within an array. 
func (r ApiListTlsIngestProfileOriginsRequest) Filter(filter string) ApiListTlsIngestProfileOriginsRequest {
	r.filter = &filter
	return r
}
// Specifies an object field name to sort results on. Provide a comma-separated list of field names for additional sort criteria. Prefix field names with a dash for descending sort order. For example, &#x60;name,-tlsIngestProfileId&#x60; sorts primarily by name, then IDs in descending order. 
func (r ApiListTlsIngestProfileOriginsRequest) SortBy(sortBy string) ApiListTlsIngestProfileOriginsRequest {
	r.sortBy = &sortBy
	return r
}
// Specifies an offset within the full set of results, with page numbers starting at 1.  Use this in conjunction with &#x60;pageSize&#x60;. 
func (r ApiListTlsIngestProfileOriginsRequest) PageNumber(pageNumber int32) ApiListTlsIngestProfileOriginsRequest {
	r.pageNumber = &pageNumber
	return r
}
// Specifies the number of results on each page.  Use this in conjunction with &#x60;pageNumber&#x60;. 
func (r ApiListTlsIngestProfileOriginsRequest) PageSize(pageSize int32) ApiListTlsIngestProfileOriginsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListTlsIngestProfileOriginsRequest) Execute() (OriginCollection, *_nethttp.Response, error) {
	return r.ApiService.ListTlsIngestProfileOriginsExecute(r)
}

/*
ListTlsIngestProfileOrigins origin per tls ingest profile

List origins for a TLS delivery profile: This operation
lists the origins associated with a specified TLS delivery
profile.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param tlsIngestProfileId Unique identifier for each TLS ingest profile. 
 @return ApiListTlsIngestProfileOriginsRequest
*/
func (a *DefaultApiService) ListTlsIngestProfileOrigins(ctx _context.Context, contentProviderId int32, tlsIngestProfileId int32) ApiListTlsIngestProfileOriginsRequest {
	return ApiListTlsIngestProfileOriginsRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		tlsIngestProfileId: tlsIngestProfileId,
	}
}

// Execute executes the request
//  @return OriginCollection
func (a *DefaultApiService) ListTlsIngestProfileOriginsExecute(r ApiListTlsIngestProfileOriginsRequest) (OriginCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OriginCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListTlsIngestProfileOrigins")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/tls-ingest-profiles/{tlsIngestProfileId}/origins"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tlsIngestProfileId"+"}", _neturl.PathEscape(parameterToString(r.tlsIngestProfileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTlsIngestProfilesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// Results display either &#x60;summary&#x60; or &#x60;detailed&#x60; objects. 
func (r ApiListTlsIngestProfilesRequest) View(view string) ApiListTlsIngestProfilesRequest {
	r.view = &view
	return r
}
// Specifies a query to filter down the set of results. The accompanying example specifies more than one query, where &#x60;;&#x60; and &#x60;,&#x60; delimiters clarify AND and OR logic. (Optional parentheses clarify logical groupings.) The &#x60;&#x3D;&#x3D;&#x60; and &#x60;!&#x3D;&#x60; operators test equivalency. The &#x60;&#x3D;lt&#x3D;&#x60;, &#x60;&#x3D;le&#x3D;&#x60;, &#x60;&#x3D;gt&#x3D;&#x60;, and &#x60;&#x3D;ge&#x3D;&#x60; operators compare numbers. The &#x60;&#x3D;contains&#x3D;&#x60; and &#x60;&#x3D;excludes&#x3D;&#x60; operators match elements within an array. 
func (r ApiListTlsIngestProfilesRequest) Filter(filter string) ApiListTlsIngestProfilesRequest {
	r.filter = &filter
	return r
}
// Specifies an object field name to sort results on. Provide a comma-separated list of field names for additional sort criteria. Prefix field names with a dash for descending sort order. For example, &#x60;name,-tlsIngestProfileId&#x60; sorts primarily by name, then IDs in descending order. 
func (r ApiListTlsIngestProfilesRequest) SortBy(sortBy string) ApiListTlsIngestProfilesRequest {
	r.sortBy = &sortBy
	return r
}
// Specifies an offset within the full set of results, with page numbers starting at 1.  Use this in conjunction with &#x60;pageSize&#x60;. 
func (r ApiListTlsIngestProfilesRequest) PageNumber(pageNumber int32) ApiListTlsIngestProfilesRequest {
	r.pageNumber = &pageNumber
	return r
}
// Specifies the number of results on each page.  Use this in conjunction with &#x60;pageNumber&#x60;. 
func (r ApiListTlsIngestProfilesRequest) PageSize(pageSize int32) ApiListTlsIngestProfilesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListTlsIngestProfilesRequest) Execute() (TlsIngestProfileCollection, *_nethttp.Response, error) {
	return r.ApiService.ListTlsIngestProfilesExecute(r)
}

/*
ListTlsIngestProfiles tls ingest profiles

List TLS ingest profiles: This operation displays the list of
TLS ingest profiles owned by the specified content provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @return ApiListTlsIngestProfilesRequest
*/
func (a *DefaultApiService) ListTlsIngestProfiles(ctx _context.Context, contentProviderId int32) ApiListTlsIngestProfilesRequest {
	return ApiListTlsIngestProfilesRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
	}
}

// Execute executes the request
//  @return TlsIngestProfileCollection
func (a *DefaultApiService) ListTlsIngestProfilesExecute(r ApiListTlsIngestProfilesRequest) (TlsIngestProfileCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TlsIngestProfileCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListTlsIngestProfiles")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/tls-ingest-profiles"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCdnPrefixRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	cdnPrefixId int32
}


func (r ApiReadCdnPrefixRequest) Execute() (CdnPrefixReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.ReadCdnPrefixExecute(r)
}

/*
ReadCdnPrefix cdn prefix

Get a CDN prefix: This operation provides a list of the CDN prefixes.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param cdnPrefixId Unique identifier for each CDN prefix. 
 @return ApiReadCdnPrefixRequest
*/
func (a *DefaultApiService) ReadCdnPrefix(ctx _context.Context, contentProviderId int32, cdnPrefixId int32) ApiReadCdnPrefixRequest {
	return ApiReadCdnPrefixRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		cdnPrefixId: cdnPrefixId,
	}
}

// Execute executes the request
//  @return CdnPrefixReadDetailed
func (a *DefaultApiService) ReadCdnPrefixExecute(r ApiReadCdnPrefixRequest) (CdnPrefixReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CdnPrefixReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadCdnPrefix")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/cdn-prefixes/{cdnPrefixId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cdnPrefixId"+"}", _neturl.PathEscape(parameterToString(r.cdnPrefixId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadCdnPrefixRulesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	cdnPrefixId int32
}


func (r ApiReadCdnPrefixRulesRequest) Execute() (CdnPrefixRules, *_nethttp.Response, error) {
	return r.ApiService.ReadCdnPrefixRulesExecute(r)
}

/*
ReadCdnPrefixRules rules

Get a rule tree: This operation displays the default rule
behaviors for a CDN prefix.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param cdnPrefixId Unique identifier for each CDN prefix. 
 @return ApiReadCdnPrefixRulesRequest
*/
func (a *DefaultApiService) ReadCdnPrefixRules(ctx _context.Context, contentProviderId int32, cdnPrefixId int32) ApiReadCdnPrefixRulesRequest {
	return ApiReadCdnPrefixRulesRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		cdnPrefixId: cdnPrefixId,
	}
}

// Execute executes the request
//  @return CdnPrefixRules
func (a *DefaultApiService) ReadCdnPrefixRulesExecute(r ApiReadCdnPrefixRulesRequest) (CdnPrefixRules, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CdnPrefixRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadCdnPrefixRules")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/cdn-prefixes/{cdnPrefixId}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cdnPrefixId"+"}", _neturl.PathEscape(parameterToString(r.cdnPrefixId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadContentProviderRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
}


func (r ApiReadContentProviderRequest) Execute() (ContentProviderReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.ReadContentProviderExecute(r)
}

/*
ReadContentProvider content provider

Get a Content Provider: This operation gets the specified Content Provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each Content Provider. 
 @return ApiReadContentProviderRequest
*/
func (a *DefaultApiService) ReadContentProvider(ctx _context.Context, contentProviderId int32) ApiReadContentProviderRequest {
	return ApiReadContentProviderRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
	}
}

// Execute executes the request
//  @return ContentProviderReadDetailed
func (a *DefaultApiService) ReadContentProviderExecute(r ApiReadContentProviderRequest) (ContentProviderReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ContentProviderReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadContentProvider")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadOriginRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	originId int32
}


func (r ApiReadOriginRequest) Execute() (OriginReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.ReadOriginExecute(r)
}

/*
ReadOrigin origin

Get an origin: This operation displays a list of origin
servers associated with a specified content provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param originId Unique identifier for each origin. 
 @return ApiReadOriginRequest
*/
func (a *DefaultApiService) ReadOrigin(ctx _context.Context, contentProviderId int32, originId int32) ApiReadOriginRequest {
	return ApiReadOriginRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		originId: originId,
	}
}

// Execute executes the request
//  @return OriginReadDetailed
func (a *DefaultApiService) ReadOriginExecute(r ApiReadOriginRequest) (OriginReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OriginReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadOrigin")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/origins/{originId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"originId"+"}", _neturl.PathEscape(parameterToString(r.originId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadSharedSecretSetRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	sharedSecretSetId int32
}


func (r ApiReadSharedSecretSetRequest) Execute() (SharedSecretSetReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.ReadSharedSecretSetExecute(r)
}

/*
ReadSharedSecretSet shared secret set

Get a shared secret set: This operation gets the details about
a shared secret set for a specified content provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param sharedSecretSetId Unique identifier for each shared secret set. 
 @return ApiReadSharedSecretSetRequest
*/
func (a *DefaultApiService) ReadSharedSecretSet(ctx _context.Context, contentProviderId int32, sharedSecretSetId int32) ApiReadSharedSecretSetRequest {
	return ApiReadSharedSecretSetRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		sharedSecretSetId: sharedSecretSetId,
	}
}

// Execute executes the request
//  @return SharedSecretSetReadDetailed
func (a *DefaultApiService) ReadSharedSecretSetExecute(r ApiReadSharedSecretSetRequest) (SharedSecretSetReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SharedSecretSetReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadSharedSecretSet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/shared-secret-sets/{sharedSecretSetId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedSecretSetId"+"}", _neturl.PathEscape(parameterToString(r.sharedSecretSetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadSharedSecretSetSecretsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	sharedSecretSetId int32
}


func (r ApiReadSharedSecretSetSecretsRequest) Execute() (SharedSecretSetSecrets, *_nethttp.Response, error) {
	return r.ApiService.ReadSharedSecretSetSecretsExecute(r)
}

/*
ReadSharedSecretSetSecrets secrets

Get secrets: This operations gets the details of a shared
secret set for a specified content provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param sharedSecretSetId Unique identifier for each shared secret set. 
 @return ApiReadSharedSecretSetSecretsRequest
*/
func (a *DefaultApiService) ReadSharedSecretSetSecrets(ctx _context.Context, contentProviderId int32, sharedSecretSetId int32) ApiReadSharedSecretSetSecretsRequest {
	return ApiReadSharedSecretSetSecretsRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		sharedSecretSetId: sharedSecretSetId,
	}
}

// Execute executes the request
//  @return SharedSecretSetSecrets
func (a *DefaultApiService) ReadSharedSecretSetSecretsExecute(r ApiReadSharedSecretSetSecretsRequest) (SharedSecretSetSecrets, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SharedSecretSetSecrets
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadSharedSecretSetSecrets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/shared-secret-sets/{sharedSecretSetId}/secrets"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedSecretSetId"+"}", _neturl.PathEscape(parameterToString(r.sharedSecretSetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadTlsDeliveryProfileRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	tlsDeliveryProfileId int32
}


func (r ApiReadTlsDeliveryProfileRequest) Execute() (TlsDeliveryProfileReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.ReadTlsDeliveryProfileExecute(r)
}

/*
ReadTlsDeliveryProfile tls delivery profile

Get a TLS delivery profile: This operation gets the specified
TLS delivery profile for the specified content provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param tlsDeliveryProfileId Unique identifier for each TLS delivery profile. 
 @return ApiReadTlsDeliveryProfileRequest
*/
func (a *DefaultApiService) ReadTlsDeliveryProfile(ctx _context.Context, contentProviderId int32, tlsDeliveryProfileId int32) ApiReadTlsDeliveryProfileRequest {
	return ApiReadTlsDeliveryProfileRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		tlsDeliveryProfileId: tlsDeliveryProfileId,
	}
}

// Execute executes the request
//  @return TlsDeliveryProfileReadDetailed
func (a *DefaultApiService) ReadTlsDeliveryProfileExecute(r ApiReadTlsDeliveryProfileRequest) (TlsDeliveryProfileReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TlsDeliveryProfileReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadTlsDeliveryProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/tls-delivery-profiles/{tlsDeliveryProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tlsDeliveryProfileId"+"}", _neturl.PathEscape(parameterToString(r.tlsDeliveryProfileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadTlsIngestProfileRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	tlsIngestProfileId int32
}


func (r ApiReadTlsIngestProfileRequest) Execute() (TlsIngestProfileReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.ReadTlsIngestProfileExecute(r)
}

/*
ReadTlsIngestProfile tls ingest profile

Get a TLS ingest profile: This operation gets details about a
specified TLS ingest profile.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param tlsIngestProfileId Unique identifier for each TLS ingest profile. 
 @return ApiReadTlsIngestProfileRequest
*/
func (a *DefaultApiService) ReadTlsIngestProfile(ctx _context.Context, contentProviderId int32, tlsIngestProfileId int32) ApiReadTlsIngestProfileRequest {
	return ApiReadTlsIngestProfileRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		tlsIngestProfileId: tlsIngestProfileId,
	}
}

// Execute executes the request
//  @return TlsIngestProfileReadDetailed
func (a *DefaultApiService) ReadTlsIngestProfileExecute(r ApiReadTlsIngestProfileRequest) (TlsIngestProfileReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TlsIngestProfileReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadTlsIngestProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/tls-ingest-profiles/{tlsIngestProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tlsIngestProfileId"+"}", _neturl.PathEscape(parameterToString(r.tlsIngestProfileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCdnPrefixRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	cdnPrefixId int32
	cdnPrefixUpdate *CdnPrefixUpdate
}

func (r ApiUpdateCdnPrefixRequest) CdnPrefixUpdate(cdnPrefixUpdate CdnPrefixUpdate) ApiUpdateCdnPrefixRequest {
	r.cdnPrefixUpdate = &cdnPrefixUpdate
	return r
}

func (r ApiUpdateCdnPrefixRequest) Execute() (CdnPrefixReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.UpdateCdnPrefixExecute(r)
}

/*
UpdateCdnPrefix cdn prefix

Update a CDN Prefix: This operation modifies an existing CDN prefix.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param cdnPrefixId Unique identifier for each CDN prefix. 
 @return ApiUpdateCdnPrefixRequest
*/
func (a *DefaultApiService) UpdateCdnPrefix(ctx _context.Context, contentProviderId int32, cdnPrefixId int32) ApiUpdateCdnPrefixRequest {
	return ApiUpdateCdnPrefixRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		cdnPrefixId: cdnPrefixId,
	}
}

// Execute executes the request
//  @return CdnPrefixReadDetailed
func (a *DefaultApiService) UpdateCdnPrefixExecute(r ApiUpdateCdnPrefixRequest) (CdnPrefixReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CdnPrefixReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateCdnPrefix")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/cdn-prefixes/{cdnPrefixId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cdnPrefixId"+"}", _neturl.PathEscape(parameterToString(r.cdnPrefixId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.cdnPrefixUpdate == nil {
		return localVarReturnValue, nil, reportError("cdnPrefixUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cdnPrefixUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCdnPrefixRulesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	cdnPrefixId int32
	cdnPrefixRules *CdnPrefixRules
}

func (r ApiUpdateCdnPrefixRulesRequest) CdnPrefixRules(cdnPrefixRules CdnPrefixRules) ApiUpdateCdnPrefixRulesRequest {
	r.cdnPrefixRules = &cdnPrefixRules
	return r
}

func (r ApiUpdateCdnPrefixRulesRequest) Execute() (CdnPrefixRules, *_nethttp.Response, error) {
	return r.ApiService.UpdateCdnPrefixRulesExecute(r)
}

/*
UpdateCdnPrefixRules rules

Update a rule tree: This operation updates the rule behaviors for a CDN prefix.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param cdnPrefixId Unique identifier for each CDN prefix. 
 @return ApiUpdateCdnPrefixRulesRequest
*/
func (a *DefaultApiService) UpdateCdnPrefixRules(ctx _context.Context, contentProviderId int32, cdnPrefixId int32) ApiUpdateCdnPrefixRulesRequest {
	return ApiUpdateCdnPrefixRulesRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		cdnPrefixId: cdnPrefixId,
	}
}

// Execute executes the request
//  @return CdnPrefixRules
func (a *DefaultApiService) UpdateCdnPrefixRulesExecute(r ApiUpdateCdnPrefixRulesRequest) (CdnPrefixRules, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CdnPrefixRules
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateCdnPrefixRules")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/cdn-prefixes/{cdnPrefixId}/rules"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"cdnPrefixId"+"}", _neturl.PathEscape(parameterToString(r.cdnPrefixId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.cdnPrefixRules == nil {
		return localVarReturnValue, nil, reportError("cdnPrefixRules is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cdnPrefixRules
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateOriginRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	originId int32
	originUpdate *OriginUpdate
}

func (r ApiUpdateOriginRequest) OriginUpdate(originUpdate OriginUpdate) ApiUpdateOriginRequest {
	r.originUpdate = &originUpdate
	return r
}

func (r ApiUpdateOriginRequest) Execute() (OriginReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.UpdateOriginExecute(r)
}

/*
UpdateOrigin origin

Update an origin: This operation modifies the origin servers
associated with a specified content provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param originId Unique identifier for each origin. 
 @return ApiUpdateOriginRequest
*/
func (a *DefaultApiService) UpdateOrigin(ctx _context.Context, contentProviderId int32, originId int32) ApiUpdateOriginRequest {
	return ApiUpdateOriginRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		originId: originId,
	}
}

// Execute executes the request
//  @return OriginReadDetailed
func (a *DefaultApiService) UpdateOriginExecute(r ApiUpdateOriginRequest) (OriginReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OriginReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateOrigin")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/origins/{originId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"originId"+"}", _neturl.PathEscape(parameterToString(r.originId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.originUpdate == nil {
		return localVarReturnValue, nil, reportError("originUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.originUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSharedSecretSetSecretsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	sharedSecretSetId int32
	sharedSecretSetSecrets *SharedSecretSetSecrets
}

func (r ApiUpdateSharedSecretSetSecretsRequest) SharedSecretSetSecrets(sharedSecretSetSecrets SharedSecretSetSecrets) ApiUpdateSharedSecretSetSecretsRequest {
	r.sharedSecretSetSecrets = &sharedSecretSetSecrets
	return r
}

func (r ApiUpdateSharedSecretSetSecretsRequest) Execute() (SharedSecretSetSecrets, *_nethttp.Response, error) {
	return r.ApiService.UpdateSharedSecretSetSecretsExecute(r)
}

/*
UpdateSharedSecretSetSecrets secrets

Update secrets: This operations updates the details of a
Shared Secret Set for a specified Content Provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param sharedSecretSetId Unique identifier for each shared secret set. 
 @return ApiUpdateSharedSecretSetSecretsRequest
*/
func (a *DefaultApiService) UpdateSharedSecretSetSecrets(ctx _context.Context, contentProviderId int32, sharedSecretSetId int32) ApiUpdateSharedSecretSetSecretsRequest {
	return ApiUpdateSharedSecretSetSecretsRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		sharedSecretSetId: sharedSecretSetId,
	}
}

// Execute executes the request
//  @return SharedSecretSetSecrets
func (a *DefaultApiService) UpdateSharedSecretSetSecretsExecute(r ApiUpdateSharedSecretSetSecretsRequest) (SharedSecretSetSecrets, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SharedSecretSetSecrets
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSharedSecretSetSecrets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/shared-secret-sets/{sharedSecretSetId}/secrets"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sharedSecretSetId"+"}", _neturl.PathEscape(parameterToString(r.sharedSecretSetId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.sharedSecretSetSecrets == nil {
		return localVarReturnValue, nil, reportError("sharedSecretSetSecrets is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharedSecretSetSecrets
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTlsDeliveryProfileRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	tlsDeliveryProfileId int32
	tlsDeliveryProfileUpdate *TlsDeliveryProfileUpdate
}

func (r ApiUpdateTlsDeliveryProfileRequest) TlsDeliveryProfileUpdate(tlsDeliveryProfileUpdate TlsDeliveryProfileUpdate) ApiUpdateTlsDeliveryProfileRequest {
	r.tlsDeliveryProfileUpdate = &tlsDeliveryProfileUpdate
	return r
}

func (r ApiUpdateTlsDeliveryProfileRequest) Execute() (TlsDeliveryProfileReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.UpdateTlsDeliveryProfileExecute(r)
}

/*
UpdateTlsDeliveryProfile tls delivery profile

Update a TLS delivery profile: After you create a content
provider TLS delivery profile, you can use this operation to
modify the profile parameters for the specified content
provider.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param tlsDeliveryProfileId Unique identifier for each TLS delivery profile. 
 @return ApiUpdateTlsDeliveryProfileRequest
*/
func (a *DefaultApiService) UpdateTlsDeliveryProfile(ctx _context.Context, contentProviderId int32, tlsDeliveryProfileId int32) ApiUpdateTlsDeliveryProfileRequest {
	return ApiUpdateTlsDeliveryProfileRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		tlsDeliveryProfileId: tlsDeliveryProfileId,
	}
}

// Execute executes the request
//  @return TlsDeliveryProfileReadDetailed
func (a *DefaultApiService) UpdateTlsDeliveryProfileExecute(r ApiUpdateTlsDeliveryProfileRequest) (TlsDeliveryProfileReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TlsDeliveryProfileReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateTlsDeliveryProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/tls-delivery-profiles/{tlsDeliveryProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tlsDeliveryProfileId"+"}", _neturl.PathEscape(parameterToString(r.tlsDeliveryProfileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tlsDeliveryProfileUpdate == nil {
		return localVarReturnValue, nil, reportError("tlsDeliveryProfileUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tlsDeliveryProfileUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateTlsIngestProfileRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	contentProviderId int32
	tlsIngestProfileId int32
	tlsIngestProfileUpdate *TlsIngestProfileUpdate
}

func (r ApiUpdateTlsIngestProfileRequest) TlsIngestProfileUpdate(tlsIngestProfileUpdate TlsIngestProfileUpdate) ApiUpdateTlsIngestProfileRequest {
	r.tlsIngestProfileUpdate = &tlsIngestProfileUpdate
	return r
}

func (r ApiUpdateTlsIngestProfileRequest) Execute() (TlsIngestProfileReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.UpdateTlsIngestProfileExecute(r)
}

/*
UpdateTlsIngestProfile tls ingest profile

Update a TLS ingest profile: After you create a TLS ingest
profile, you can modify its attributes using this operation.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param contentProviderId Unique identifier for each content provider. 
 @param tlsIngestProfileId Unique identifier for each TLS ingest profile. 
 @return ApiUpdateTlsIngestProfileRequest
*/
func (a *DefaultApiService) UpdateTlsIngestProfile(ctx _context.Context, contentProviderId int32, tlsIngestProfileId int32) ApiUpdateTlsIngestProfileRequest {
	return ApiUpdateTlsIngestProfileRequest{
		ApiService: a,
		ctx: ctx,
		contentProviderId: contentProviderId,
		tlsIngestProfileId: tlsIngestProfileId,
	}
}

// Execute executes the request
//  @return TlsIngestProfileReadDetailed
func (a *DefaultApiService) UpdateTlsIngestProfileExecute(r ApiUpdateTlsIngestProfileRequest) (TlsIngestProfileReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  TlsIngestProfileReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateTlsIngestProfile")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/content-providers/{contentProviderId}/tls-ingest-profiles/{tlsIngestProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"contentProviderId"+"}", _neturl.PathEscape(parameterToString(r.contentProviderId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tlsIngestProfileId"+"}", _neturl.PathEscape(parameterToString(r.tlsIngestProfileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.tlsIngestProfileUpdate == nil {
		return localVarReturnValue, nil, reportError("tlsIngestProfileUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tlsIngestProfileUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
