/*
infrastructure

Infrastructure API

API version: v1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package infrastructure

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

type DefaultApi interface {

	/*
	CreateAttributeType Attribute types

	Create a new attribute type: This operation creates a new attribute type. A CDN Operator has the option to create a global set of node attribute types that provide additional node information to CDN Operators, IT, or support organizations.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiCreateAttributeTypeRequest
	*/
	CreateAttributeType(ctx _context.Context) ApiCreateAttributeTypeRequest

	// CreateAttributeTypeExecute executes the request
	//  @return AttributeTypeRead
	CreateAttributeTypeExecute(r ApiCreateAttributeTypeRequest) (AttributeTypeRead, *_nethttp.Response, error)

	/*
	CreateNode Nodes

	Create a new node: This operation creates a new node.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiCreateNodeRequest
	*/
	CreateNode(ctx _context.Context) ApiCreateNodeRequest

	// CreateNodeExecute executes the request
	//  @return NodeReadDetailed
	CreateNodeExecute(r ApiCreateNodeRequest) (NodeReadDetailed, *_nethttp.Response, error)

	/*
	CreateSite Sites

	Create a new site: This operation creates a new site.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiCreateSiteRequest
	*/
	CreateSite(ctx _context.Context) ApiCreateSiteRequest

	// CreateSiteExecute executes the request
	//  @return SiteReadDetailed
	CreateSiteExecute(r ApiCreateSiteRequest) (SiteReadDetailed, *_nethttp.Response, error)

	/*
	DeleteAttributeType AttributeType Instance.

	Remove an attribute type: This operation removes an attribute type.  A CDN Operator has the option to create a global set of node attribute types that provide additional node information to CDN Operators, IT, or support organizations. Removing an attribute type removes that attribute type and its values from all nodes to which it is assigned.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param attributeTypeId Uniquely identifies an attribute type. 
	 @return ApiDeleteAttributeTypeRequest
	*/
	DeleteAttributeType(ctx _context.Context, attributeTypeId int32) ApiDeleteAttributeTypeRequest

	// DeleteAttributeTypeExecute executes the request
	DeleteAttributeTypeExecute(r ApiDeleteAttributeTypeRequest) (*_nethttp.Response, error)

	/*
	DeleteNode Node Instance.

	Remove a node: This operation removes a node.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param nodeId Uniquely identifies a node. 
	 @return ApiDeleteNodeRequest
	*/
	DeleteNode(ctx _context.Context, nodeId int32) ApiDeleteNodeRequest

	// DeleteNodeExecute executes the request
	DeleteNodeExecute(r ApiDeleteNodeRequest) (*_nethttp.Response, error)

	/*
	DeleteSite Site Instance.

	Remove a site: Remove a site.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param siteId Uniquely identifies a site. 
	 @return ApiDeleteSiteRequest
	*/
	DeleteSite(ctx _context.Context, siteId int32) ApiDeleteSiteRequest

	// DeleteSiteExecute executes the request
	DeleteSiteExecute(r ApiDeleteSiteRequest) (*_nethttp.Response, error)

	/*
	ListAttributeTypes Attribute types

	List attribute types: This operation returns a list of all
configured attribute types.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListAttributeTypesRequest
	*/
	ListAttributeTypes(ctx _context.Context) ApiListAttributeTypesRequest

	// ListAttributeTypesExecute executes the request
	//  @return AttributeTypeCollection
	ListAttributeTypesExecute(r ApiListAttributeTypesRequest) (AttributeTypeCollection, *_nethttp.Response, error)

	/*
	ListNodes Nodes

	List nodes: This operation returns a list of all configured
nodes.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListNodesRequest
	*/
	ListNodes(ctx _context.Context) ApiListNodesRequest

	// ListNodesExecute executes the request
	//  @return NodeCollection
	ListNodesExecute(r ApiListNodesRequest) (NodeCollection, *_nethttp.Response, error)

	/*
	ListSiteNodes nodes per site

	List nodes per site: This operation lists the nodes belonging to this site.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param siteId Uniquely identifies a site. 
	 @return ApiListSiteNodesRequest
	*/
	ListSiteNodes(ctx _context.Context, siteId int32) ApiListSiteNodesRequest

	// ListSiteNodesExecute executes the request
	//  @return NodeCollection
	ListSiteNodesExecute(r ApiListSiteNodesRequest) (NodeCollection, *_nethttp.Response, error)

	/*
	ListSites Sites

	List sites: This operation returns a list of all configured
sites.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiListSitesRequest
	*/
	ListSites(ctx _context.Context) ApiListSitesRequest

	// ListSitesExecute executes the request
	//  @return SiteCollection
	ListSitesExecute(r ApiListSitesRequest) (SiteCollection, *_nethttp.Response, error)

	/*
	ReadAttributeType AttributeType Instance.

	Get an attribute type: This operation retrieves the details of an attribute type.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param attributeTypeId Uniquely identifies an attribute type. 
	 @return ApiReadAttributeTypeRequest
	*/
	ReadAttributeType(ctx _context.Context, attributeTypeId int32) ApiReadAttributeTypeRequest

	// ReadAttributeTypeExecute executes the request
	//  @return AttributeTypeRead
	ReadAttributeTypeExecute(r ApiReadAttributeTypeRequest) (AttributeTypeRead, *_nethttp.Response, error)

	/*
	ReadAttributeTypeSettings AttributeType Settings

	Get settings: This operation gets the configured attribute type settings which are a set of values the CDN Operator creates to apply to an attribute type.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiReadAttributeTypeSettingsRequest
	*/
	ReadAttributeTypeSettings(ctx _context.Context) ApiReadAttributeTypeSettingsRequest

	// ReadAttributeTypeSettingsExecute executes the request
	//  @return AttributeTypeSettings
	ReadAttributeTypeSettingsExecute(r ApiReadAttributeTypeSettingsRequest) (AttributeTypeSettings, *_nethttp.Response, error)

	/*
	ReadNode Node Instance.

	Get a node: This operation retrieves the details of a node.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param nodeId Uniquely identifies a node. 
	 @return ApiReadNodeRequest
	*/
	ReadNode(ctx _context.Context, nodeId int32) ApiReadNodeRequest

	// ReadNodeExecute executes the request
	//  @return NodeReadDetailed
	ReadNodeExecute(r ApiReadNodeRequest) (NodeReadDetailed, *_nethttp.Response, error)

	/*
	ReadNodeBootMedium NodeBootMedium

	Get a node boot image: Before you install a service node, you must create a Service Node Installation Image on a USB device. You can create either a USB image or an ISO image. Each new LCDN or LMS service node boots the first time from the Service Node Installation Image to install the required service node software on each service node. After the installation is complete, you must remove the USB device so that from that point forward the node boots off its hard disk.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiReadNodeBootMediumRequest
	*/
	ReadNodeBootMedium(ctx _context.Context) ApiReadNodeBootMediumRequest

	// ReadNodeBootMediumExecute executes the request
	ReadNodeBootMediumExecute(r ApiReadNodeBootMediumRequest) (*_nethttp.Response, error)

	/*
	ReadSite Site Instance.

	Get a site: This operation retrieves the details of a site.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param siteId Uniquely identifies a site. 
	 @return ApiReadSiteRequest
	*/
	ReadSite(ctx _context.Context, siteId int32) ApiReadSiteRequest

	// ReadSiteExecute executes the request
	//  @return SiteReadDetailed
	ReadSiteExecute(r ApiReadSiteRequest) (SiteReadDetailed, *_nethttp.Response, error)

	/*
	UpdateAttributeType AttributeType Instance.

	Update an attribute type: This operation updates the details of an attribute type.  A CDN Operator has the option to create a global set of node attribute types that provide additional node information to CDN Operators, IT, or support organizations.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param attributeTypeId Uniquely identifies an attribute type. 
	 @return ApiUpdateAttributeTypeRequest
	*/
	UpdateAttributeType(ctx _context.Context, attributeTypeId int32) ApiUpdateAttributeTypeRequest

	// UpdateAttributeTypeExecute executes the request
	//  @return AttributeTypeRead
	UpdateAttributeTypeExecute(r ApiUpdateAttributeTypeRequest) (AttributeTypeRead, *_nethttp.Response, error)

	/*
	UpdateAttributeTypeSettings AttributeType Settings

	Update settings: This operation updates attribute type settings which are a set of values the CDN Operator creates to apply to an attribute type.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @return ApiUpdateAttributeTypeSettingsRequest
	*/
	UpdateAttributeTypeSettings(ctx _context.Context) ApiUpdateAttributeTypeSettingsRequest

	// UpdateAttributeTypeSettingsExecute executes the request
	//  @return AttributeTypeSettings
	UpdateAttributeTypeSettingsExecute(r ApiUpdateAttributeTypeSettingsRequest) (AttributeTypeSettings, *_nethttp.Response, error)

	/*
	UpdateNode Node Instance.

	Update a node: This operation updates the details of a node.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param nodeId Uniquely identifies a node. 
	 @return ApiUpdateNodeRequest
	*/
	UpdateNode(ctx _context.Context, nodeId int32) ApiUpdateNodeRequest

	// UpdateNodeExecute executes the request
	//  @return NodeReadDetailed
	UpdateNodeExecute(r ApiUpdateNodeRequest) (NodeReadDetailed, *_nethttp.Response, error)

	/*
	UpdateSite Site Instance.

	Update a site: This operation updates the details of a site.


	 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 @param siteId Uniquely identifies a site. 
	 @return ApiUpdateSiteRequest
	*/
	UpdateSite(ctx _context.Context, siteId int32) ApiUpdateSiteRequest

	// UpdateSiteExecute executes the request
	//  @return SiteReadDetailed
	UpdateSiteExecute(r ApiUpdateSiteRequest) (SiteReadDetailed, *_nethttp.Response, error)
}

// DefaultApiService DefaultApi service
type DefaultApiService service

type ApiCreateAttributeTypeRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	attributeTypeCreate *AttributeTypeCreate
}

func (r ApiCreateAttributeTypeRequest) AttributeTypeCreate(attributeTypeCreate AttributeTypeCreate) ApiCreateAttributeTypeRequest {
	r.attributeTypeCreate = &attributeTypeCreate
	return r
}

func (r ApiCreateAttributeTypeRequest) Execute() (AttributeTypeRead, *_nethttp.Response, error) {
	return r.ApiService.CreateAttributeTypeExecute(r)
}

/*
CreateAttributeType Attribute types

Create a new attribute type: This operation creates a new attribute type. A CDN Operator has the option to create a global set of node attribute types that provide additional node information to CDN Operators, IT, or support organizations.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAttributeTypeRequest
*/
func (a *DefaultApiService) CreateAttributeType(ctx _context.Context) ApiCreateAttributeTypeRequest {
	return ApiCreateAttributeTypeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeTypeRead
func (a *DefaultApiService) CreateAttributeTypeExecute(r ApiCreateAttributeTypeRequest) (AttributeTypeRead, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeTypeRead
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateAttributeType")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.attributeTypeCreate == nil {
		return localVarReturnValue, nil, reportError("attributeTypeCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.attributeTypeCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNodeRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	nodeCreate *NodeCreate
}

func (r ApiCreateNodeRequest) NodeCreate(nodeCreate NodeCreate) ApiCreateNodeRequest {
	r.nodeCreate = &nodeCreate
	return r
}

func (r ApiCreateNodeRequest) Execute() (NodeReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.CreateNodeExecute(r)
}

/*
CreateNode Nodes

Create a new node: This operation creates a new node.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNodeRequest
*/
func (a *DefaultApiService) CreateNode(ctx _context.Context) ApiCreateNodeRequest {
	return ApiCreateNodeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NodeReadDetailed
func (a *DefaultApiService) CreateNodeExecute(r ApiCreateNodeRequest) (NodeReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NodeReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateNode")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.nodeCreate == nil {
		return localVarReturnValue, nil, reportError("nodeCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nodeCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSiteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	siteCreate *SiteCreate
}

func (r ApiCreateSiteRequest) SiteCreate(siteCreate SiteCreate) ApiCreateSiteRequest {
	r.siteCreate = &siteCreate
	return r
}

func (r ApiCreateSiteRequest) Execute() (SiteReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.CreateSiteExecute(r)
}

/*
CreateSite Sites

Create a new site: This operation creates a new site.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSiteRequest
*/
func (a *DefaultApiService) CreateSite(ctx _context.Context) ApiCreateSiteRequest {
	return ApiCreateSiteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SiteReadDetailed
func (a *DefaultApiService) CreateSiteExecute(r ApiCreateSiteRequest) (SiteReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SiteReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.CreateSite")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.siteCreate == nil {
		return localVarReturnValue, nil, reportError("siteCreate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.siteCreate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAttributeTypeRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	attributeTypeId int32
}


func (r ApiDeleteAttributeTypeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteAttributeTypeExecute(r)
}

/*
DeleteAttributeType AttributeType Instance.

Remove an attribute type: This operation removes an attribute type.  A CDN Operator has the option to create a global set of node attribute types that provide additional node information to CDN Operators, IT, or support organizations. Removing an attribute type removes that attribute type and its values from all nodes to which it is assigned.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attributeTypeId Uniquely identifies an attribute type. 
 @return ApiDeleteAttributeTypeRequest
*/
func (a *DefaultApiService) DeleteAttributeType(ctx _context.Context, attributeTypeId int32) ApiDeleteAttributeTypeRequest {
	return ApiDeleteAttributeTypeRequest{
		ApiService: a,
		ctx: ctx,
		attributeTypeId: attributeTypeId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteAttributeTypeExecute(r ApiDeleteAttributeTypeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteAttributeType")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute-types/{attributeTypeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"attributeTypeId"+"}", _neturl.PathEscape(parameterToString(r.attributeTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteNodeRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	nodeId int32
}


func (r ApiDeleteNodeRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteNodeExecute(r)
}

/*
DeleteNode Node Instance.

Remove a node: This operation removes a node.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Uniquely identifies a node. 
 @return ApiDeleteNodeRequest
*/
func (a *DefaultApiService) DeleteNode(ctx _context.Context, nodeId int32) ApiDeleteNodeRequest {
	return ApiDeleteNodeRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteNodeExecute(r ApiDeleteNodeRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteNode")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", _neturl.PathEscape(parameterToString(r.nodeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSiteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	siteId int32
}


func (r ApiDeleteSiteRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteSiteExecute(r)
}

/*
DeleteSite Site Instance.

Remove a site: Remove a site.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId Uniquely identifies a site. 
 @return ApiDeleteSiteRequest
*/
func (a *DefaultApiService) DeleteSite(ctx _context.Context, siteId int32) ApiDeleteSiteRequest {
	return ApiDeleteSiteRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
func (a *DefaultApiService) DeleteSiteExecute(r ApiDeleteSiteRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.DeleteSite")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiListAttributeTypesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// The view parameter may be used to request that either the summary or detailed view be returned.
func (r ApiListAttributeTypesRequest) View(view string) ApiListAttributeTypesRequest {
	r.view = &view
	return r
}
// The filter parameter may be used to filter the returned collection.
func (r ApiListAttributeTypesRequest) Filter(filter string) ApiListAttributeTypesRequest {
	r.filter = &filter
	return r
}
// The sortBy parameter may be used to specify the sort order of the returned collection.
func (r ApiListAttributeTypesRequest) SortBy(sortBy string) ApiListAttributeTypesRequest {
	r.sortBy = &sortBy
	return r
}
// The pageNumber parameter may be used to specify an offset into the results.  Useful to use in conjunction with pageSize.  Page number offset is 1-based.
func (r ApiListAttributeTypesRequest) PageNumber(pageNumber int32) ApiListAttributeTypesRequest {
	r.pageNumber = &pageNumber
	return r
}
// The pageSize parameter may be used to specify the page size of the returned results.  Useful to use in conjunction with pageNumber.
func (r ApiListAttributeTypesRequest) PageSize(pageSize int32) ApiListAttributeTypesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListAttributeTypesRequest) Execute() (AttributeTypeCollection, *_nethttp.Response, error) {
	return r.ApiService.ListAttributeTypesExecute(r)
}

/*
ListAttributeTypes Attribute types

List attribute types: This operation returns a list of all
configured attribute types.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAttributeTypesRequest
*/
func (a *DefaultApiService) ListAttributeTypes(ctx _context.Context) ApiListAttributeTypesRequest {
	return ApiListAttributeTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeTypeCollection
func (a *DefaultApiService) ListAttributeTypesExecute(r ApiListAttributeTypesRequest) (AttributeTypeCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeTypeCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListAttributeTypes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute-types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListNodesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// The view parameter may be used to request that either the summary or detailed view be returned.
func (r ApiListNodesRequest) View(view string) ApiListNodesRequest {
	r.view = &view
	return r
}
// The filter parameter may be used to filter the returned collection.
func (r ApiListNodesRequest) Filter(filter string) ApiListNodesRequest {
	r.filter = &filter
	return r
}
// The sortBy parameter may be used to specify the sort order of the returned collection.
func (r ApiListNodesRequest) SortBy(sortBy string) ApiListNodesRequest {
	r.sortBy = &sortBy
	return r
}
// The pageNumber parameter may be used to specify an offset into the results.  Useful to use in conjunction with pageSize.  Page number offset is 1-based.
func (r ApiListNodesRequest) PageNumber(pageNumber int32) ApiListNodesRequest {
	r.pageNumber = &pageNumber
	return r
}
// The pageSize parameter may be used to specify the page size of the returned results.  Useful to use in conjunction with pageNumber.
func (r ApiListNodesRequest) PageSize(pageSize int32) ApiListNodesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListNodesRequest) Execute() (NodeCollection, *_nethttp.Response, error) {
	return r.ApiService.ListNodesExecute(r)
}

/*
ListNodes Nodes

List nodes: This operation returns a list of all configured
nodes.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListNodesRequest
*/
func (a *DefaultApiService) ListNodes(ctx _context.Context) ApiListNodesRequest {
	return ApiListNodesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return NodeCollection
func (a *DefaultApiService) ListNodesExecute(r ApiListNodesRequest) (NodeCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NodeCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListNodes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSiteNodesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	siteId int32
}


func (r ApiListSiteNodesRequest) Execute() (NodeCollection, *_nethttp.Response, error) {
	return r.ApiService.ListSiteNodesExecute(r)
}

/*
ListSiteNodes nodes per site

List nodes per site: This operation lists the nodes belonging to this site.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId Uniquely identifies a site. 
 @return ApiListSiteNodesRequest
*/
func (a *DefaultApiService) ListSiteNodes(ctx _context.Context, siteId int32) ApiListSiteNodesRequest {
	return ApiListSiteNodesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return NodeCollection
func (a *DefaultApiService) ListSiteNodesExecute(r ApiListSiteNodesRequest) (NodeCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NodeCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSiteNodes")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{siteId}/nodes"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSitesRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	view *string
	filter *string
	sortBy *string
	pageNumber *int32
	pageSize *int32
}

// The view parameter may be used to request that either the summary or detailed view be returned.
func (r ApiListSitesRequest) View(view string) ApiListSitesRequest {
	r.view = &view
	return r
}
// The filter parameter may be used to filter the returned collection.
func (r ApiListSitesRequest) Filter(filter string) ApiListSitesRequest {
	r.filter = &filter
	return r
}
// The sortBy parameter may be used to specify the sort order of the returned collection.
func (r ApiListSitesRequest) SortBy(sortBy string) ApiListSitesRequest {
	r.sortBy = &sortBy
	return r
}
// The pageNumber parameter may be used to specify an offset into the results.  Useful to use in conjunction with pageSize.  Page number offset is 1-based.
func (r ApiListSitesRequest) PageNumber(pageNumber int32) ApiListSitesRequest {
	r.pageNumber = &pageNumber
	return r
}
// The pageSize parameter may be used to specify the page size of the returned results.  Useful to use in conjunction with pageNumber.
func (r ApiListSitesRequest) PageSize(pageSize int32) ApiListSitesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiListSitesRequest) Execute() (SiteCollection, *_nethttp.Response, error) {
	return r.ApiService.ListSitesExecute(r)
}

/*
ListSites Sites

List sites: This operation returns a list of all configured
sites.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListSitesRequest
*/
func (a *DefaultApiService) ListSites(ctx _context.Context) ApiListSitesRequest {
	return ApiListSitesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SiteCollection
func (a *DefaultApiService) ListSitesExecute(r ApiListSitesRequest) (SiteCollection, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SiteCollection
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ListSites")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.view != nil {
		localVarQueryParams.Add("view", parameterToString(*r.view, ""))
	}
	if r.filter != nil {
		localVarQueryParams.Add("filter", parameterToString(*r.filter, ""))
	}
	if r.sortBy != nil {
		localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadAttributeTypeRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	attributeTypeId int32
}


func (r ApiReadAttributeTypeRequest) Execute() (AttributeTypeRead, *_nethttp.Response, error) {
	return r.ApiService.ReadAttributeTypeExecute(r)
}

/*
ReadAttributeType AttributeType Instance.

Get an attribute type: This operation retrieves the details of an attribute type.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attributeTypeId Uniquely identifies an attribute type. 
 @return ApiReadAttributeTypeRequest
*/
func (a *DefaultApiService) ReadAttributeType(ctx _context.Context, attributeTypeId int32) ApiReadAttributeTypeRequest {
	return ApiReadAttributeTypeRequest{
		ApiService: a,
		ctx: ctx,
		attributeTypeId: attributeTypeId,
	}
}

// Execute executes the request
//  @return AttributeTypeRead
func (a *DefaultApiService) ReadAttributeTypeExecute(r ApiReadAttributeTypeRequest) (AttributeTypeRead, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeTypeRead
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadAttributeType")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute-types/{attributeTypeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"attributeTypeId"+"}", _neturl.PathEscape(parameterToString(r.attributeTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadAttributeTypeSettingsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
}


func (r ApiReadAttributeTypeSettingsRequest) Execute() (AttributeTypeSettings, *_nethttp.Response, error) {
	return r.ApiService.ReadAttributeTypeSettingsExecute(r)
}

/*
ReadAttributeTypeSettings AttributeType Settings

Get settings: This operation gets the configured attribute type settings which are a set of values the CDN Operator creates to apply to an attribute type.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReadAttributeTypeSettingsRequest
*/
func (a *DefaultApiService) ReadAttributeTypeSettings(ctx _context.Context) ApiReadAttributeTypeSettingsRequest {
	return ApiReadAttributeTypeSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeTypeSettings
func (a *DefaultApiService) ReadAttributeTypeSettingsExecute(r ApiReadAttributeTypeSettingsRequest) (AttributeTypeSettings, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeTypeSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadAttributeTypeSettings")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute-types/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadNodeRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	nodeId int32
}


func (r ApiReadNodeRequest) Execute() (NodeReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.ReadNodeExecute(r)
}

/*
ReadNode Node Instance.

Get a node: This operation retrieves the details of a node.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Uniquely identifies a node. 
 @return ApiReadNodeRequest
*/
func (a *DefaultApiService) ReadNode(ctx _context.Context, nodeId int32) ApiReadNodeRequest {
	return ApiReadNodeRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return NodeReadDetailed
func (a *DefaultApiService) ReadNodeExecute(r ApiReadNodeRequest) (NodeReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NodeReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadNode")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", _neturl.PathEscape(parameterToString(r.nodeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadNodeBootMediumRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	format *string
}

// &#x60;usb&#x60; or &#x60;iso&#x60;. 
func (r ApiReadNodeBootMediumRequest) Format(format string) ApiReadNodeBootMediumRequest {
	r.format = &format
	return r
}

func (r ApiReadNodeBootMediumRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.ReadNodeBootMediumExecute(r)
}

/*
ReadNodeBootMedium NodeBootMedium

Get a node boot image: Before you install a service node, you must create a Service Node Installation Image on a USB device. You can create either a USB image or an ISO image. Each new LCDN or LMS service node boots the first time from the Service Node Installation Image to install the required service node software on each service node. After the installation is complete, you must remove the USB device so that from that point forward the node boots off its hard disk.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReadNodeBootMediumRequest
*/
func (a *DefaultApiService) ReadNodeBootMedium(ctx _context.Context) ApiReadNodeBootMediumRequest {
	return ApiReadNodeBootMediumRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DefaultApiService) ReadNodeBootMediumExecute(r ApiReadNodeBootMediumRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadNodeBootMedium")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/boot-medium"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.format == nil {
		return nil, reportError("format is required and must be specified")
	}

	localVarQueryParams.Add("format", parameterToString(*r.format, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReadSiteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	siteId int32
}


func (r ApiReadSiteRequest) Execute() (SiteReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.ReadSiteExecute(r)
}

/*
ReadSite Site Instance.

Get a site: This operation retrieves the details of a site.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId Uniquely identifies a site. 
 @return ApiReadSiteRequest
*/
func (a *DefaultApiService) ReadSite(ctx _context.Context, siteId int32) ApiReadSiteRequest {
	return ApiReadSiteRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return SiteReadDetailed
func (a *DefaultApiService) ReadSiteExecute(r ApiReadSiteRequest) (SiteReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SiteReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.ReadSite")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAttributeTypeRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	attributeTypeId int32
	attributeTypeUpdate *AttributeTypeUpdate
}

func (r ApiUpdateAttributeTypeRequest) AttributeTypeUpdate(attributeTypeUpdate AttributeTypeUpdate) ApiUpdateAttributeTypeRequest {
	r.attributeTypeUpdate = &attributeTypeUpdate
	return r
}

func (r ApiUpdateAttributeTypeRequest) Execute() (AttributeTypeRead, *_nethttp.Response, error) {
	return r.ApiService.UpdateAttributeTypeExecute(r)
}

/*
UpdateAttributeType AttributeType Instance.

Update an attribute type: This operation updates the details of an attribute type.  A CDN Operator has the option to create a global set of node attribute types that provide additional node information to CDN Operators, IT, or support organizations.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param attributeTypeId Uniquely identifies an attribute type. 
 @return ApiUpdateAttributeTypeRequest
*/
func (a *DefaultApiService) UpdateAttributeType(ctx _context.Context, attributeTypeId int32) ApiUpdateAttributeTypeRequest {
	return ApiUpdateAttributeTypeRequest{
		ApiService: a,
		ctx: ctx,
		attributeTypeId: attributeTypeId,
	}
}

// Execute executes the request
//  @return AttributeTypeRead
func (a *DefaultApiService) UpdateAttributeTypeExecute(r ApiUpdateAttributeTypeRequest) (AttributeTypeRead, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeTypeRead
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateAttributeType")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute-types/{attributeTypeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"attributeTypeId"+"}", _neturl.PathEscape(parameterToString(r.attributeTypeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.attributeTypeUpdate == nil {
		return localVarReturnValue, nil, reportError("attributeTypeUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.attributeTypeUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAttributeTypeSettingsRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	attributeTypeSettings *AttributeTypeSettings
}

func (r ApiUpdateAttributeTypeSettingsRequest) AttributeTypeSettings(attributeTypeSettings AttributeTypeSettings) ApiUpdateAttributeTypeSettingsRequest {
	r.attributeTypeSettings = &attributeTypeSettings
	return r
}

func (r ApiUpdateAttributeTypeSettingsRequest) Execute() (AttributeTypeSettings, *_nethttp.Response, error) {
	return r.ApiService.UpdateAttributeTypeSettingsExecute(r)
}

/*
UpdateAttributeTypeSettings AttributeType Settings

Update settings: This operation updates attribute type settings which are a set of values the CDN Operator creates to apply to an attribute type.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateAttributeTypeSettingsRequest
*/
func (a *DefaultApiService) UpdateAttributeTypeSettings(ctx _context.Context) ApiUpdateAttributeTypeSettingsRequest {
	return ApiUpdateAttributeTypeSettingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AttributeTypeSettings
func (a *DefaultApiService) UpdateAttributeTypeSettingsExecute(r ApiUpdateAttributeTypeSettingsRequest) (AttributeTypeSettings, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  AttributeTypeSettings
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateAttributeTypeSettings")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/attribute-types/settings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.attributeTypeSettings == nil {
		return localVarReturnValue, nil, reportError("attributeTypeSettings is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.attributeTypeSettings
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateNodeRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	nodeId int32
	nodeUpdate *NodeUpdate
}

func (r ApiUpdateNodeRequest) NodeUpdate(nodeUpdate NodeUpdate) ApiUpdateNodeRequest {
	r.nodeUpdate = &nodeUpdate
	return r
}

func (r ApiUpdateNodeRequest) Execute() (NodeReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.UpdateNodeExecute(r)
}

/*
UpdateNode Node Instance.

Update a node: This operation updates the details of a node.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param nodeId Uniquely identifies a node. 
 @return ApiUpdateNodeRequest
*/
func (a *DefaultApiService) UpdateNode(ctx _context.Context, nodeId int32) ApiUpdateNodeRequest {
	return ApiUpdateNodeRequest{
		ApiService: a,
		ctx: ctx,
		nodeId: nodeId,
	}
}

// Execute executes the request
//  @return NodeReadDetailed
func (a *DefaultApiService) UpdateNodeExecute(r ApiUpdateNodeRequest) (NodeReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  NodeReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateNode")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/nodes/{nodeId}"
	localVarPath = strings.Replace(localVarPath, "{"+"nodeId"+"}", _neturl.PathEscape(parameterToString(r.nodeId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.nodeUpdate == nil {
		return localVarReturnValue, nil, reportError("nodeUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nodeUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSiteRequest struct {
	ctx _context.Context
	ApiService DefaultApi
	siteId int32
	siteUpdate *SiteUpdate
}

func (r ApiUpdateSiteRequest) SiteUpdate(siteUpdate SiteUpdate) ApiUpdateSiteRequest {
	r.siteUpdate = &siteUpdate
	return r
}

func (r ApiUpdateSiteRequest) Execute() (SiteReadDetailed, *_nethttp.Response, error) {
	return r.ApiService.UpdateSiteExecute(r)
}

/*
UpdateSite Site Instance.

Update a site: This operation updates the details of a site.


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId Uniquely identifies a site. 
 @return ApiUpdateSiteRequest
*/
func (a *DefaultApiService) UpdateSite(ctx _context.Context, siteId int32) ApiUpdateSiteRequest {
	return ApiUpdateSiteRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return SiteReadDetailed
func (a *DefaultApiService) UpdateSiteExecute(r ApiUpdateSiteRequest) (SiteReadDetailed, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SiteReadDetailed
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultApiService.UpdateSite")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sites/{siteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"siteId"+"}", _neturl.PathEscape(parameterToString(r.siteId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.siteUpdate == nil {
		return localVarReturnValue, nil, reportError("siteUpdate is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.siteUpdate
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
